{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Breaking RSA Encryption The security of RSA encryption, as briefly described below, is based on the computational difficulty of factoring large numbers. The best-known algorithm, General Number Field Sieve by (Lenstra et al., 1990a) performs this task in sub-exponential time \\(O\\left(e^{1.9(\\log N)^{1/3}(\\log\\log N)^{2/3}}\\right)\\) , where \\(N\\) is the number being factored (then \\(\\log N\\) would be the order of the number of input bits) In 1994, Peter Shor came up with a Las Vegas algorithm for prime factorization and discrete logarithms that take advantage of quantum computation to achieve a polynomial complexity in the number of bits, which is \\(O\\left((\\log N)^2(\\log\\log N)(\\log \\log\\log N)\\right)\\) . RSA Preliminaries Suppose Alice wants to send a message \\(a\\) to Bob (as an ASCII integer). Bob picks two prime numbers (preferably large) \\(p\\) and \\(q\\) and multiplies them to get \\(N=pq\\) . Also, he chooses a large number \\(c\\) , coprime with \\((p-1)(q-1)\\) . After that, he shares with Alice the public keys \\((N,c)\\) . Alice uses the keys received from Bob to encrypt the message, calculating \\(b\\equiv a^c~(mod ~N)\\) , and sends it to Bob. Since he knows \\(p\\) and \\(q\\) , she can compute \\(d\\) (private key) such that \\(cd\\equiv1 ~(mod~ (p-1)(q-1))\\) thought B\u00e9zout coefficients of Extended Euclidean algorithm , then he can decrypt the message \\(b\\) , through \\(b^d~(mod~N)\\) . This works because \\(a^{(p-1)(q-1)}\\equiv 1 ~(mod~N)\\) , and since \\(cd\\) can be written as \\(1+k(p-1)(q-1)\\) for some \\(k\\in\\mathbb{Z}\\) , we get: \\[\\begin{align*} &b^d~(mod~N)\\\\ \\equiv&~a^{cd}~(mod~N)\\\\ \\equiv&~a^{1+k(p-1)(q-1)}~(mod~N)\\\\ \\equiv&~a~(mod~N) \\end{align*}\\] This is just a summary, for a deeper explanation of the group theory involved in this encryption, you can check sections 3.2 and 3.3 of (Mermin, 2007) . But now, we understand the \"vulnerability\" of RSA. If a hacker gets \\(p\\) and \\(q\\) just knowing its product \\(N\\) , he could effortlessly generate the private key \\(d\\) and decrypt the message. That's why in practical applications, \\(p\\) and \\(q\\) are huge numbers with hundreds of digits of length. Project Structure Section 2 describes Shor's Algorithm and the number theory behind it. It relies on finding the period \\(r\\) of a discrete periodic function, in that case \\(f(x)=a^x~(mod~N)\\) . That's the key part of the algorithm which can be done efficiently on a quantum computer, using the Quantum Fourier Transform (QFT), presented in Section 4 . Section 3 gives a basic background in quantum computing concepts, and how to implement quantum circuits using Qiskit library , for then you jump into the QFT section. Finally, Section 5 shows a practical example of factoring using a quantum computer. We use \\(15\\) for the experiment and explain the caveats for factoring higher order numbers. Section 6 is a selection of excellent materials available on the internet regarding quantum computing and cryptography. And Section 7 contains the bibliographical references.","title":"1 - Introduction"},{"location":"#breaking-rsa-encryption","text":"The security of RSA encryption, as briefly described below, is based on the computational difficulty of factoring large numbers. The best-known algorithm, General Number Field Sieve by (Lenstra et al., 1990a) performs this task in sub-exponential time \\(O\\left(e^{1.9(\\log N)^{1/3}(\\log\\log N)^{2/3}}\\right)\\) , where \\(N\\) is the number being factored (then \\(\\log N\\) would be the order of the number of input bits) In 1994, Peter Shor came up with a Las Vegas algorithm for prime factorization and discrete logarithms that take advantage of quantum computation to achieve a polynomial complexity in the number of bits, which is \\(O\\left((\\log N)^2(\\log\\log N)(\\log \\log\\log N)\\right)\\) .","title":"Breaking RSA Encryption"},{"location":"#rsa-preliminaries","text":"Suppose Alice wants to send a message \\(a\\) to Bob (as an ASCII integer). Bob picks two prime numbers (preferably large) \\(p\\) and \\(q\\) and multiplies them to get \\(N=pq\\) . Also, he chooses a large number \\(c\\) , coprime with \\((p-1)(q-1)\\) . After that, he shares with Alice the public keys \\((N,c)\\) . Alice uses the keys received from Bob to encrypt the message, calculating \\(b\\equiv a^c~(mod ~N)\\) , and sends it to Bob. Since he knows \\(p\\) and \\(q\\) , she can compute \\(d\\) (private key) such that \\(cd\\equiv1 ~(mod~ (p-1)(q-1))\\) thought B\u00e9zout coefficients of Extended Euclidean algorithm , then he can decrypt the message \\(b\\) , through \\(b^d~(mod~N)\\) . This works because \\(a^{(p-1)(q-1)}\\equiv 1 ~(mod~N)\\) , and since \\(cd\\) can be written as \\(1+k(p-1)(q-1)\\) for some \\(k\\in\\mathbb{Z}\\) , we get: \\[\\begin{align*} &b^d~(mod~N)\\\\ \\equiv&~a^{cd}~(mod~N)\\\\ \\equiv&~a^{1+k(p-1)(q-1)}~(mod~N)\\\\ \\equiv&~a~(mod~N) \\end{align*}\\] This is just a summary, for a deeper explanation of the group theory involved in this encryption, you can check sections 3.2 and 3.3 of (Mermin, 2007) . But now, we understand the \"vulnerability\" of RSA. If a hacker gets \\(p\\) and \\(q\\) just knowing its product \\(N\\) , he could effortlessly generate the private key \\(d\\) and decrypt the message. That's why in practical applications, \\(p\\) and \\(q\\) are huge numbers with hundreds of digits of length.","title":"RSA Preliminaries"},{"location":"#project-structure","text":"Section 2 describes Shor's Algorithm and the number theory behind it. It relies on finding the period \\(r\\) of a discrete periodic function, in that case \\(f(x)=a^x~(mod~N)\\) . That's the key part of the algorithm which can be done efficiently on a quantum computer, using the Quantum Fourier Transform (QFT), presented in Section 4 . Section 3 gives a basic background in quantum computing concepts, and how to implement quantum circuits using Qiskit library , for then you jump into the QFT section. Finally, Section 5 shows a practical example of factoring using a quantum computer. We use \\(15\\) for the experiment and explain the caveats for factoring higher order numbers. Section 6 is a selection of excellent materials available on the internet regarding quantum computing and cryptography. And Section 7 contains the bibliographical references.","title":"Project Structure"},{"location":"bib/","text":"References A. K. Lenstra, H. W. Lenstra, M. S. Manasse, and J. M. Pollard. 1990. The number field sieve. In Proceedings of the twenty-second annual ACM symposium on Theory of Computing (STOC '90). Association for Computing Machinery, New York, NY, USA, 564\u2013572. DOI:https://doi.org/10.1145/100216.100295 Mermin, N. D. (2007). Quantum Computer Science. Cambridge University Press.","title":"7 - References"},{"location":"bib/#references","text":"A. K. Lenstra, H. W. Lenstra, M. S. Manasse, and J. M. Pollard. 1990. The number field sieve. In Proceedings of the twenty-second annual ACM symposium on Theory of Computing (STOC '90). Association for Computing Machinery, New York, NY, USA, 564\u2013572. DOI:https://doi.org/10.1145/100216.100295 Mermin, N. D. (2007). Quantum Computer Science. Cambridge University Press.","title":"References"},{"location":"further/","text":"Further Reading Recommended materials Qiskit Summer Course - Introduction to Quantum Computing and Quantum Hardware Original Shor's paper Mermin's book - Quantum Computer Science Qiskit textbook Shor's interview Breaking Elliptic Curve encryption on Quantum Computers","title":"6 - Further reading"},{"location":"further/#further-reading","text":"Recommended materials Qiskit Summer Course - Introduction to Quantum Computing and Quantum Hardware Original Shor's paper Mermin's book - Quantum Computer Science Qiskit textbook Shor's interview Breaking Elliptic Curve encryption on Quantum Computers","title":"Further Reading"},{"location":"intro-quantum/","text":"Introduction to Quantum Computing Qubits, dirac notation, measurements, bloch sphere, quantum circuits, q-sphere","title":"3 - Quantum Computing Preliminaries"},{"location":"intro-quantum/#introduction-to-quantum-computing","text":"Qubits, dirac notation, measurements, bloch sphere, quantum circuits, q-sphere","title":"Introduction to Quantum Computing"},{"location":"qft/","text":"Quantum Fourier Transform \\[QFT_N \\vert x \\rangle = \\frac{1}{\\sqrt{N}} \\sum_{y=0}^{N-1} e^{2 \\pi i xy / 2^n} \\vert y \\rangle\\] import numpy as np from numpy import pi warnings.filterwarnings(\"ignore\") # importing Qiskit from qiskit import QuantumCircuit, transpile, assemble, Aer, IBMQ from qiskit.providers.ibmq import least_busy from qiskit.tools.monitor import job_monitor from qiskit.visualization import plot_histogram, plot_bloch_multivector import warnings qc = QuantumCircuit(3) qc.h(2) qc.draw() q_0: \u2500\u2500\u2500\u2500\u2500 q_1: \u2500\u2500\u2500\u2500\u2500 \u250c\u2500\u2500\u2500\u2510 q_2: \u2524 H \u251c \u2514\u2500\u2500\u2500\u2518 qc.cp(pi/2, 1, 2) # CROT from qubit 1 to qubit 2 qc.draw() q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u250c\u2500\u2500\u2500\u2510 \u2502P(\u03c0/2) q_2: \u2524 H \u251c\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2514\u2500\u2500\u2500\u2518","title":"4 - Quantum Fourier Transform"},{"location":"qft/#quantum-fourier-transform","text":"\\[QFT_N \\vert x \\rangle = \\frac{1}{\\sqrt{N}} \\sum_{y=0}^{N-1} e^{2 \\pi i xy / 2^n} \\vert y \\rangle\\] import numpy as np from numpy import pi warnings.filterwarnings(\"ignore\") # importing Qiskit from qiskit import QuantumCircuit, transpile, assemble, Aer, IBMQ from qiskit.providers.ibmq import least_busy from qiskit.tools.monitor import job_monitor from qiskit.visualization import plot_histogram, plot_bloch_multivector import warnings qc = QuantumCircuit(3) qc.h(2) qc.draw() q_0: \u2500\u2500\u2500\u2500\u2500 q_1: \u2500\u2500\u2500\u2500\u2500 \u250c\u2500\u2500\u2500\u2510 q_2: \u2524 H \u251c \u2514\u2500\u2500\u2500\u2518 qc.cp(pi/2, 1, 2) # CROT from qubit 1 to qubit 2 qc.draw() q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u250c\u2500\u2500\u2500\u2510 \u2502P(\u03c0/2) q_2: \u2524 H \u251c\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2514\u2500\u2500\u2500\u2518","title":"Quantum Fourier Transform"},{"location":"quantum-shors/","text":"Quantum Shor's Algorithm","title":"5 - Quantum Shor's Algorithm"},{"location":"quantum-shors/#quantum-shors-algorithm","text":"","title":"Quantum Shor's Algorithm"},{"location":"shors-algorithm/","text":"Shor's Algorithm import markdown md = markdown.Markdown(extensions=['pymdownx.arithmatex']) Pseudocode Getting straight to the point, here's how Shor's algorithm works to factor a prime product \\(N=pq\\) : Pick a random integer \\(a\\) between \\(0\\) and \\(N-1\\) ; Find the smallest \\(r\\) such that \\(a^r\\equiv 1 ~(mod ~N)\\) , i.e the period of the function \\(f(x)=a^x~(mod~N)\\) ; If r is odd, get back to step 1 If \\(a^{r/2}+1\\equiv 0~(mod~N)\\) , get back to step 1. Then \\(\\{p,q\\}=\\{\\gcd(a^{r/2}-1,N),\\gcd(a^{r/2}+1,N)\\}\\) . Why does it works? Let \\(G_N\\) be the set of all positive integers less than N, that are coprimes with N. One can show that this is a group under modulo- \\(N\\) multiplication. Step 1 chooses a random \\(a\\in \\mathbb{Z}_N\\) , if we are lucky to choose an \\(a\\) which share factors with \\(N\\) , we just use Euclidean Algorithm for \\(\\gcd(N,a)\\) and finish the factoring process. But in most cases we'll choose a number in \\(G_N\\) . Step 2 finds the order \\(r\\) of \\(a\\) in \\(G_N\\) . Then, we calculate \\(x=a^{r/2}~(mod~N)\\) (step 3 garantees \\(r\\) is even), and open up the expression: \\[\\begin{align*} (x-1)(x+1)&\\equiv x^2-1~(mod ~N)\\\\ &\\equiv a^r-1~(mod ~N)\\\\ &\\equiv 0 ~(mod ~N),\\\\ \\end{align*}\\] since \\(a^r\\equiv1~(mod~N)\\) Note that \\(x-1\\not\\equiv 0 ~(mod ~N)\\) , because \\(r\\) is the smallest number s.t. \\(a^r-1\\equiv0~(mod~N)\\) , so \\(a^{r/2}-1\\) does not satisfy the equivalence. Step 4, also garantees \\(x+1\\not\\equiv0~(mod~N)\\) . So, we have that neither \\(x-1\\) nor \\(x+1\\) is divisible by \\(N=pq\\) , but their product \\((x-1)(x+1)\\) is. Since \\(N\\) has just two prime factors, \\(p\\) must divide \\(x-1\\) or \\(x+1\\) and \\(q\\) the other term. Probability of Success Shor's Algorithm counts on the luck of finding an \\(a\\) which goes through steps 3 and 4 without restarting the process. But we don't need to try it out many times because the probability of a random number \\(a\\in G_N\\) have order \\(r\\) which is even and satisfy \\(a^{r/2}+1\\not\\equiv0~(mod~N)\\) , is at least \\(50\\%\\) ! We'll prove a more general theorem: Theorem 1: Let \\(N=p_1^{\\alpha_1}p_2^{\\alpha_2}\\ldots p_m^{\\alpha_m}\\) the prime factorization of a positive composite number \\(N\\) . If \\(a\\) is an uniformly random number choosen from \\(G_N\\) , and \\(r\\) its order modulo \\(N\\) , then: \\[\\mathbb{P}\\left(\\text{r is even and }a^{r/2}+1\\not\\equiv0~(mod~N)\\right )\\geq1-\\dfrac{1}{2^{m-1}}\\] Then, in the case where \\(N=pq\\) ( \\(m=2\\) ), the probability of success is greater or equal \\(1/2\\) . At first, consider \\(N\\) being an odd prime number (because even primes won't appear in encryption applications). We'll have \\(|G_N|=\\varphi(N)=N-1\\) , an even number, so consider \\(2^d\\) the large power of 2 diving \\(N-1\\) . As said before, it can be show that \\(G_N\\) is a cyclic group under modulo \\(N\\) multiplication. So there is a generator \\(g\\) such that any element from \\(G_N\\) can be written as \\(g^t~(mod~N)\\) . If \\(r\\) is the order of \\(g^t\\) , then \\(g^{tr}\\equiv1~(mod~N)\\) . By Lagrange's Theorem , \\(tr|N-1\\) . If \\(t\\) is odd, then \\(2^d\\) must divide \\(r\\) , so \\(r\\) is even. If \\(t\\) happens to be even, we'll have: \\[g^{(N-1)t/2}\\equiv(g^{(N-1)})^{t/2}\\equiv1~(mod~N),\\] so \\(r|(N-1)/2\\) since \\(r\\) is the order of \\(g^t\\) and \\((g^t)^{(N-1)/2}\\equiv1~(mod~N)\\) . This implies that \\(2^d\\) does not divide \\(r\\) , because if that was the case, we would have \\(2^{d+1}|N-1\\) , absurd by the definition of \\(2^d\\) as largest power of two dividing \\(N-1\\) . So, the probability of a random number in \\(G_N\\) have an order divisible by \\(2^d\\) is 1/2 (because \\(t\\) is equaly likely to be odd or even). Now, consider \\(N\\) being power of an odd prime \\(N=p^{\\alpha}\\) . The same argument still holds replacing \\(N-1\\) by \\(|G_N| = \\varphi(N)=p^{\\alpha-1}(p-1)\\) . So, if \\(2^d\\) is the largest power of two dividing \\(\\varphi(N)\\) , then a randomly choosen \\(a\\in G_N\\) have its order \\(r\\) divisible by \\(2^d\\) with probability \\(1/2\\) . We're gonnna prove the general case where \\(N=p_1^{\\alpha_1}p_2^{\\alpha_2}\\ldots p_m^{\\alpha_m}\\) , as a consequence of the following theorem: Theorem 2 (Chinese Remainder Theorem): Suppose \\(n_1,n_2,\\ldots,n_k\\) are positive integers pairwise coprimes. Then the system of equations: \\begin{align } x &\\equiv a_1~(mod~n_1)\\ x &\\equiv a_2~(mod~n_2)\\ \\vdots&~~~~~\\vdots~~~~~~~~~\\vdots\\ x &\\equiv a_k~(mod~n_k) \\end{align } has a solution. Moreover, if \\(x_1\\) and \\(x_2\\) are solutions, \\(x_1\\equiv x_2~(mod~N)\\) , where \\(N=n_1n_2\\ldots n_k\\) . By the above theorem, choosing \\(a\\in G_N\\) randomly, is equivalent to choose for each \\(i=1,\\ldots,m\\) , a random \\(a_i\\in G_{p_i^{\\alpha_i}}\\) , and requiring \\(a\\equiv a_i~(mod~p_i^{\\alpha_i})\\) for all \\(i\\) . Let \\(r_i\\) be the order of \\(a_i~(mod~p_i^{\\alpha_i})\\) , and \\(2^{d_i}\\) the largest power of two dividing \\(r_i\\) . The order \\(r\\) of \\(a\\) will be the lowest commom divisor of \\(r_1,\\ldots,r_m\\) . Shor's algorithm only fails if all powers \\(2^{d_i}\\) agree. If \\(d_i=0~\\forall~i=1,\\ldots,m\\) , then \\(r\\) will be odd. For each \\(i\\) , the probability of \\(r_i\\) beaing odd is \\(1/2\\) , since we are in the case of power of a prime \\(p_i^{\\alpha_i}\\) . Then of \\(r_i\\) 's will be odd, with probability \\(1/2^{m}\\) . The other case of failure is when \\(r\\) is even and \\(a^{r/2}\\equiv-1~(mod~N)\\) . If this happens, then for all \\(i\\) , \\(a^{r/2}\\equiv-1~(mod~p_i^{\\alpha_i})\\) . So \\(r_i\\) does not divides \\(r/2\\) , because if that was the case \\(a^{r/2}\\) would be \\(1\\) modulo \\(p_i^{\\alpha_i}\\) . Since \\(r_i|r\\) , all of \\(d_i\\) 's must agree. As seen before, \\(r_1\\) will be divisible by a power of \\(2\\) (the largest dividing \\(\\varphi(p_1^{\\alpha_2}\\) ) with probability \\(1/2\\) . Then the probability of each other \\(r_i\\) 's have it's \\(d_i\\) agreeing with \\(d_1\\) will be at most \\(1/2\\) (considering the worst case scenario). Then \\(\\mathbb{P}(r\\text{ even and }a^{r/2}\\equiv-1~(mod~N))\\leq\\dfrac1{2^m}\\) . And since \\(\\mathbb{P}(r \\text{ odd}=\\dfrac1{2^m}\\) , then probability of failure is: \\[\\mathbb{P}(r\\text{ odd or }a^{r/2}\\equiv-1~(mod~N))\\leq\\dfrac1{2^m}+\\dfrac{1}{2^m}=\\dfrac{1}{2^{m-1}}\\] Finally, the probability of sucess is \\[\\mathbb{P}(r\\text{ even and }a^{r/2}\\not\\equiv-1~(mod~N))\\geq1-\\dfrac{1}{2^{m-1}} ~~\\blacksquare\\]","title":"2 - Shor's Algorithm"},{"location":"shors-algorithm/#shors-algorithm","text":"import markdown md = markdown.Markdown(extensions=['pymdownx.arithmatex'])","title":"Shor's Algorithm"},{"location":"shors-algorithm/#pseudocode","text":"Getting straight to the point, here's how Shor's algorithm works to factor a prime product \\(N=pq\\) : Pick a random integer \\(a\\) between \\(0\\) and \\(N-1\\) ; Find the smallest \\(r\\) such that \\(a^r\\equiv 1 ~(mod ~N)\\) , i.e the period of the function \\(f(x)=a^x~(mod~N)\\) ; If r is odd, get back to step 1 If \\(a^{r/2}+1\\equiv 0~(mod~N)\\) , get back to step 1. Then \\(\\{p,q\\}=\\{\\gcd(a^{r/2}-1,N),\\gcd(a^{r/2}+1,N)\\}\\) .","title":"Pseudocode"},{"location":"shors-algorithm/#why-does-it-works","text":"Let \\(G_N\\) be the set of all positive integers less than N, that are coprimes with N. One can show that this is a group under modulo- \\(N\\) multiplication. Step 1 chooses a random \\(a\\in \\mathbb{Z}_N\\) , if we are lucky to choose an \\(a\\) which share factors with \\(N\\) , we just use Euclidean Algorithm for \\(\\gcd(N,a)\\) and finish the factoring process. But in most cases we'll choose a number in \\(G_N\\) . Step 2 finds the order \\(r\\) of \\(a\\) in \\(G_N\\) . Then, we calculate \\(x=a^{r/2}~(mod~N)\\) (step 3 garantees \\(r\\) is even), and open up the expression: \\[\\begin{align*} (x-1)(x+1)&\\equiv x^2-1~(mod ~N)\\\\ &\\equiv a^r-1~(mod ~N)\\\\ &\\equiv 0 ~(mod ~N),\\\\ \\end{align*}\\] since \\(a^r\\equiv1~(mod~N)\\) Note that \\(x-1\\not\\equiv 0 ~(mod ~N)\\) , because \\(r\\) is the smallest number s.t. \\(a^r-1\\equiv0~(mod~N)\\) , so \\(a^{r/2}-1\\) does not satisfy the equivalence. Step 4, also garantees \\(x+1\\not\\equiv0~(mod~N)\\) . So, we have that neither \\(x-1\\) nor \\(x+1\\) is divisible by \\(N=pq\\) , but their product \\((x-1)(x+1)\\) is. Since \\(N\\) has just two prime factors, \\(p\\) must divide \\(x-1\\) or \\(x+1\\) and \\(q\\) the other term.","title":"Why does it works?"},{"location":"shors-algorithm/#probability-of-success","text":"Shor's Algorithm counts on the luck of finding an \\(a\\) which goes through steps 3 and 4 without restarting the process. But we don't need to try it out many times because the probability of a random number \\(a\\in G_N\\) have order \\(r\\) which is even and satisfy \\(a^{r/2}+1\\not\\equiv0~(mod~N)\\) , is at least \\(50\\%\\) ! We'll prove a more general theorem: Theorem 1: Let \\(N=p_1^{\\alpha_1}p_2^{\\alpha_2}\\ldots p_m^{\\alpha_m}\\) the prime factorization of a positive composite number \\(N\\) . If \\(a\\) is an uniformly random number choosen from \\(G_N\\) , and \\(r\\) its order modulo \\(N\\) , then: \\[\\mathbb{P}\\left(\\text{r is even and }a^{r/2}+1\\not\\equiv0~(mod~N)\\right )\\geq1-\\dfrac{1}{2^{m-1}}\\] Then, in the case where \\(N=pq\\) ( \\(m=2\\) ), the probability of success is greater or equal \\(1/2\\) . At first, consider \\(N\\) being an odd prime number (because even primes won't appear in encryption applications). We'll have \\(|G_N|=\\varphi(N)=N-1\\) , an even number, so consider \\(2^d\\) the large power of 2 diving \\(N-1\\) . As said before, it can be show that \\(G_N\\) is a cyclic group under modulo \\(N\\) multiplication. So there is a generator \\(g\\) such that any element from \\(G_N\\) can be written as \\(g^t~(mod~N)\\) . If \\(r\\) is the order of \\(g^t\\) , then \\(g^{tr}\\equiv1~(mod~N)\\) . By Lagrange's Theorem , \\(tr|N-1\\) . If \\(t\\) is odd, then \\(2^d\\) must divide \\(r\\) , so \\(r\\) is even. If \\(t\\) happens to be even, we'll have: \\[g^{(N-1)t/2}\\equiv(g^{(N-1)})^{t/2}\\equiv1~(mod~N),\\] so \\(r|(N-1)/2\\) since \\(r\\) is the order of \\(g^t\\) and \\((g^t)^{(N-1)/2}\\equiv1~(mod~N)\\) . This implies that \\(2^d\\) does not divide \\(r\\) , because if that was the case, we would have \\(2^{d+1}|N-1\\) , absurd by the definition of \\(2^d\\) as largest power of two dividing \\(N-1\\) . So, the probability of a random number in \\(G_N\\) have an order divisible by \\(2^d\\) is 1/2 (because \\(t\\) is equaly likely to be odd or even). Now, consider \\(N\\) being power of an odd prime \\(N=p^{\\alpha}\\) . The same argument still holds replacing \\(N-1\\) by \\(|G_N| = \\varphi(N)=p^{\\alpha-1}(p-1)\\) . So, if \\(2^d\\) is the largest power of two dividing \\(\\varphi(N)\\) , then a randomly choosen \\(a\\in G_N\\) have its order \\(r\\) divisible by \\(2^d\\) with probability \\(1/2\\) . We're gonnna prove the general case where \\(N=p_1^{\\alpha_1}p_2^{\\alpha_2}\\ldots p_m^{\\alpha_m}\\) , as a consequence of the following theorem: Theorem 2 (Chinese Remainder Theorem): Suppose \\(n_1,n_2,\\ldots,n_k\\) are positive integers pairwise coprimes. Then the system of equations: \\begin{align } x &\\equiv a_1~(mod~n_1)\\ x &\\equiv a_2~(mod~n_2)\\ \\vdots&~~~~~\\vdots~~~~~~~~~\\vdots\\ x &\\equiv a_k~(mod~n_k) \\end{align } has a solution. Moreover, if \\(x_1\\) and \\(x_2\\) are solutions, \\(x_1\\equiv x_2~(mod~N)\\) , where \\(N=n_1n_2\\ldots n_k\\) . By the above theorem, choosing \\(a\\in G_N\\) randomly, is equivalent to choose for each \\(i=1,\\ldots,m\\) , a random \\(a_i\\in G_{p_i^{\\alpha_i}}\\) , and requiring \\(a\\equiv a_i~(mod~p_i^{\\alpha_i})\\) for all \\(i\\) . Let \\(r_i\\) be the order of \\(a_i~(mod~p_i^{\\alpha_i})\\) , and \\(2^{d_i}\\) the largest power of two dividing \\(r_i\\) . The order \\(r\\) of \\(a\\) will be the lowest commom divisor of \\(r_1,\\ldots,r_m\\) . Shor's algorithm only fails if all powers \\(2^{d_i}\\) agree. If \\(d_i=0~\\forall~i=1,\\ldots,m\\) , then \\(r\\) will be odd. For each \\(i\\) , the probability of \\(r_i\\) beaing odd is \\(1/2\\) , since we are in the case of power of a prime \\(p_i^{\\alpha_i}\\) . Then of \\(r_i\\) 's will be odd, with probability \\(1/2^{m}\\) . The other case of failure is when \\(r\\) is even and \\(a^{r/2}\\equiv-1~(mod~N)\\) . If this happens, then for all \\(i\\) , \\(a^{r/2}\\equiv-1~(mod~p_i^{\\alpha_i})\\) . So \\(r_i\\) does not divides \\(r/2\\) , because if that was the case \\(a^{r/2}\\) would be \\(1\\) modulo \\(p_i^{\\alpha_i}\\) . Since \\(r_i|r\\) , all of \\(d_i\\) 's must agree. As seen before, \\(r_1\\) will be divisible by a power of \\(2\\) (the largest dividing \\(\\varphi(p_1^{\\alpha_2}\\) ) with probability \\(1/2\\) . Then the probability of each other \\(r_i\\) 's have it's \\(d_i\\) agreeing with \\(d_1\\) will be at most \\(1/2\\) (considering the worst case scenario). Then \\(\\mathbb{P}(r\\text{ even and }a^{r/2}\\equiv-1~(mod~N))\\leq\\dfrac1{2^m}\\) . And since \\(\\mathbb{P}(r \\text{ odd}=\\dfrac1{2^m}\\) , then probability of failure is: \\[\\mathbb{P}(r\\text{ odd or }a^{r/2}\\equiv-1~(mod~N))\\leq\\dfrac1{2^m}+\\dfrac{1}{2^m}=\\dfrac{1}{2^{m-1}}\\] Finally, the probability of sucess is \\[\\mathbb{P}(r\\text{ even and }a^{r/2}\\not\\equiv-1~(mod~N))\\geq1-\\dfrac{1}{2^{m-1}} ~~\\blacksquare\\]","title":"Probability of Success"}]}