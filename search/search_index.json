{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Breaking RSA Encryption The security of RSA encryption, as briefly described below, is based on the computational difficulty of factoring large numbers. The best-known algorithm, General Number Field Sieve by (Lenstra et al., 1990a) performs this task in sub-exponential time \\(O\\left(e^{1.9(\\log N)^{1/3}(\\log\\log N)^{2/3}}\\right)\\) , where \\(N\\) is the number being factored (then \\(\\log N\\) would be the order of the number of input bits) In 1994, Peter Shor came up with a Las Vegas algorithm for prime factorization and discrete logarithms that take advantage of quantum computation to achieve a polynomial complexity in the number of bits, which is \\(O\\left((\\log N)^2(\\log\\log N)(\\log \\log\\log N)\\right)\\) . RSA Preliminaries Suppose Alice wants to send a message \\(a\\) to Bob (as an ASCII integer). Bob picks two prime numbers (preferably large) \\(p\\) and \\(q\\) and multiplies them to get \\(N=pq\\) . Also, he chooses a large number \\(c\\) , coprime with \\((p-1)(q-1)\\) . After that, he shares with Alice the public keys \\((N,c)\\) . Alice uses the keys received from Bob to encrypt the message, calculating \\(b\\equiv a^c~(mod ~N)\\) , and sends it to Bob. Since he knows \\(p\\) and \\(q\\) , she can compute \\(d\\) (private key) such that \\(cd\\equiv1 ~(mod~ (p-1)(q-1))\\) thought B\u00e9zout coefficients of Extended Euclidean algorithm , then he can decrypt the message \\(b\\) , through \\(b^d~(mod~N)\\) . This works because \\(a^{(p-1)(q-1)}\\equiv 1 ~(mod~N)\\) , and since \\(cd\\) can be written as \\(1+k(p-1)(q-1)\\) for some \\(k\\in\\mathbb{Z}\\) , we get: \\[\\begin{align*} &b^d~(mod~N)\\\\ \\equiv&~a^{cd}~(mod~N)\\\\ \\equiv&~a^{1+k(p-1)(q-1)}~(mod~N)\\\\ \\equiv&~a~(mod~N) \\end{align*}\\] This is just a summary, for a deeper explanation of the group theory involved in this encryption, you can check sections 3.2 and 3.3 of (Mermin, 2007) . But now, we understand the \"vulnerability\" of RSA. If a hacker gets \\(p\\) and \\(q\\) just knowing its product \\(N\\) , he could effortlessly generate the private key \\(d\\) and decrypt the message. That's why in practical applications, \\(p\\) and \\(q\\) are huge numbers with hundreds of digits of length. Project Structure Section 2 describes Shor's Algorithm and the number theory behind it. It relies on finding the period \\(r\\) of a discrete periodic function, in that case \\(f(x)=a^x~(mod~N)\\) . That's the key part of the algorithm which can be done efficiently on a quantum computer, using the Quantum Fourier Transform (QFT), presented in Section 4 . Section 3 gives a basic background in quantum computing concepts, and how to implement quantum circuits using Qiskit library , for then you jump into the QFT section. Finally, Section 5 shows a practical example of factoring using a quantum computer. We use \\(15\\) for the experiment and explain the caveats for factoring higher order numbers. Section 6 is a selection of excellent materials available on the internet regarding quantum computing and cryptography. And Section 7 contains the bibliographical references.","title":"1 - Introduction"},{"location":"#breaking-rsa-encryption","text":"The security of RSA encryption, as briefly described below, is based on the computational difficulty of factoring large numbers. The best-known algorithm, General Number Field Sieve by (Lenstra et al., 1990a) performs this task in sub-exponential time \\(O\\left(e^{1.9(\\log N)^{1/3}(\\log\\log N)^{2/3}}\\right)\\) , where \\(N\\) is the number being factored (then \\(\\log N\\) would be the order of the number of input bits) In 1994, Peter Shor came up with a Las Vegas algorithm for prime factorization and discrete logarithms that take advantage of quantum computation to achieve a polynomial complexity in the number of bits, which is \\(O\\left((\\log N)^2(\\log\\log N)(\\log \\log\\log N)\\right)\\) .","title":"Breaking RSA Encryption"},{"location":"#rsa-preliminaries","text":"Suppose Alice wants to send a message \\(a\\) to Bob (as an ASCII integer). Bob picks two prime numbers (preferably large) \\(p\\) and \\(q\\) and multiplies them to get \\(N=pq\\) . Also, he chooses a large number \\(c\\) , coprime with \\((p-1)(q-1)\\) . After that, he shares with Alice the public keys \\((N,c)\\) . Alice uses the keys received from Bob to encrypt the message, calculating \\(b\\equiv a^c~(mod ~N)\\) , and sends it to Bob. Since he knows \\(p\\) and \\(q\\) , she can compute \\(d\\) (private key) such that \\(cd\\equiv1 ~(mod~ (p-1)(q-1))\\) thought B\u00e9zout coefficients of Extended Euclidean algorithm , then he can decrypt the message \\(b\\) , through \\(b^d~(mod~N)\\) . This works because \\(a^{(p-1)(q-1)}\\equiv 1 ~(mod~N)\\) , and since \\(cd\\) can be written as \\(1+k(p-1)(q-1)\\) for some \\(k\\in\\mathbb{Z}\\) , we get: \\[\\begin{align*} &b^d~(mod~N)\\\\ \\equiv&~a^{cd}~(mod~N)\\\\ \\equiv&~a^{1+k(p-1)(q-1)}~(mod~N)\\\\ \\equiv&~a~(mod~N) \\end{align*}\\] This is just a summary, for a deeper explanation of the group theory involved in this encryption, you can check sections 3.2 and 3.3 of (Mermin, 2007) . But now, we understand the \"vulnerability\" of RSA. If a hacker gets \\(p\\) and \\(q\\) just knowing its product \\(N\\) , he could effortlessly generate the private key \\(d\\) and decrypt the message. That's why in practical applications, \\(p\\) and \\(q\\) are huge numbers with hundreds of digits of length.","title":"RSA Preliminaries"},{"location":"#project-structure","text":"Section 2 describes Shor's Algorithm and the number theory behind it. It relies on finding the period \\(r\\) of a discrete periodic function, in that case \\(f(x)=a^x~(mod~N)\\) . That's the key part of the algorithm which can be done efficiently on a quantum computer, using the Quantum Fourier Transform (QFT), presented in Section 4 . Section 3 gives a basic background in quantum computing concepts, and how to implement quantum circuits using Qiskit library , for then you jump into the QFT section. Finally, Section 5 shows a practical example of factoring using a quantum computer. We use \\(15\\) for the experiment and explain the caveats for factoring higher order numbers. Section 6 is a selection of excellent materials available on the internet regarding quantum computing and cryptography. And Section 7 contains the bibliographical references.","title":"Project Structure"},{"location":"bib/","text":"References A. K. Lenstra, H. W. Lenstra, M. S. Manasse, and J. M. Pollard. 1990. The number field sieve. In Proceedings of the twenty-second annual ACM symposium on Theory of Computing (STOC '90). Association for Computing Machinery, New York, NY, USA, 564\u2013572. DOI:https://doi.org/10.1145/100216.100295 Mermin, N. D. (2007). Quantum Computer Science. Cambridge University Press. Nielsen, M. A., & Chuang, I. L. (2011). Quantum Computation and Quantum Information: 10th Anniversary Edition (1st ed.). Cambridge University Press.","title":"7 - References"},{"location":"bib/#references","text":"A. K. Lenstra, H. W. Lenstra, M. S. Manasse, and J. M. Pollard. 1990. The number field sieve. In Proceedings of the twenty-second annual ACM symposium on Theory of Computing (STOC '90). Association for Computing Machinery, New York, NY, USA, 564\u2013572. DOI:https://doi.org/10.1145/100216.100295 Mermin, N. D. (2007). Quantum Computer Science. Cambridge University Press. Nielsen, M. A., & Chuang, I. L. (2011). Quantum Computation and Quantum Information: 10th Anniversary Edition (1st ed.). Cambridge University Press.","title":"References"},{"location":"further/","text":"Further Reading Recommended materials Qiskit Summer Course - Introduction to Quantum Computing and Quantum Hardware Original Shor's paper Mermin's book - Quantum Computer Science Qiskit textbook Shor's interview Breaking Elliptic Curve encryption on Quantum Computers","title":"6 - Further reading"},{"location":"further/#further-reading","text":"Recommended materials Qiskit Summer Course - Introduction to Quantum Computing and Quantum Hardware Original Shor's paper Mermin's book - Quantum Computer Science Qiskit textbook Shor's interview Breaking Elliptic Curve encryption on Quantum Computers","title":"Further Reading"},{"location":"intro-quantum/","text":"Introduction to Quantum Computing In classical computation, states (bits) are either 0 or 1, but quantum mechanics allows superposition of states, so a quantum state can be simultaneously 0 and 1. Such a superposition allows quantum computers to make calculations on more than one state at the same time. That's what makes possible the design of algorithms with exponentially speed-up such as Shor's Algorithm, which reduces to polynomial time, a task that runs in exponential time on classical computers. A quantum state in superposition can be measured, but once we do that, it collapses to one of its states with a given probability. That's what makes the design of quantum algorithms harder than classical ones because we have to draw a system that collapses to what we want with a high probability. This section seeks to introduce just the basic foundations of quantum computing as a background for the following sections. No prerequisite in quantum physics/mechanics is required. We'll present everything from the mathematical point of view, demanding just some prior knowledge in Linear Algebra and Complex Numbers. Quantum States and Dirac Notation We represent a \\(n\\) -qubit quantum state as a normalized vector in \\(\\mathbb{C}^{2^n}\\) (that's it!). Take for example, the single-qubit states \\(a,b\\in \\mathbb{C}^2\\) such that \\(a=\\left(\\begin{matrix}a_1\\\\ a_2\\end{matrix}\\right)\\) and \\(b=\\left(\\begin{matrix}b_1\\\\ b_2\\end{matrix}\\right)\\) with \\(a_1,a_2,b_1,b_2\\in\\mathbb{C}\\) . The so called Dirac notation is a shortcut for representing states and operations between them. ket: \\(\\vert a\\rangle = \\left(\\begin{matrix}a_1\\\\ a_2\\end{matrix}\\right)\\) The most used notation around this text, it's the way we represent a quantum state. bra: \\(\\langle b \\vert = \\vert b \\rangle^\\dagger=\\left(\\begin{matrix}b_1\\\\ b_2\\end{matrix}\\right)^\\dagger=\\left(\\begin{matrix}\\overline{b_1}& \\overline b_2\\end{matrix}\\right)\\) The bra is the conjugate transpose of a state (dagger notation \\(\\dagger\\) ). \\(\\overline b_1\\) means the complex conjugate of \\(b_1\\) . bra-ket: \\(\\langle b \\vert a\\rangle=a_1\\overline b_1+a_2\\overline b_2\\) A \"inner product\" between states. Observe that \\(\\langle b \\vert a\\rangle = \\overline {\\langle a\\vert b \\rangle}\\) . We say \\(a\\) and \\(b\\) are orthogonal states if \\(\\langle a\\vert b\\rangle = 0\\) . Not every complex vector can represent quantum states, because they need to be normalized, i.e, all states \\(\\vert\\psi\\rangle\\) must satisfy \\(\\langle\\psi\\vert\\psi\\rangle=1\\) . We define states \\(\\vert0\\rangle := \\left(\\begin{matrix}1\\\\0\\end{matrix}\\right)\\) and \\(\\vert1\\rangle:=\\left(\\begin{matrix}0\\\\1\\end{matrix}\\right)\\) . It's easy to see that \\(\\langle0\\vert1\\rangle=0\\) , so \\(\\vert0\\rangle\\) and \\(\\vert1\\rangle\\) are orthogonal. The general single-qubit state is then: \\[\\vert\\psi\\rangle = \\alpha_0\\vert0\\rangle+\\alpha_1\\vert1\\rangle,\\] with \\(\\alpha_0,\\alpha_1\\in\\mathbb{C}\\) and \\(|\\alpha_0|^2+|\\alpha_1|^2=1\\) We also define the tensor product of two states as: \\[\\vert a\\rangle\\otimes\\vert b\\rangle = \\left(\\begin{matrix}a_1b_1\\\\a_1b_2\\\\a_2b_1\\\\a_2b_2\\end{matrix}\\right)\\] This operation generalizes what we're doing in \\(\\mathbb{C}^2\\) to \\(\\mathbb{C}^{2^n}\\) . We defines the n-qubit computational basis as the set of all \\(2^n\\) possible tensor products of \\(\\vert0\\rangle\\) and \\(\\vert1\\rangle\\) . We can also represent tensor product with the notation \\(\\vert x_1x_2\\ldots x_n\\rangle:=x_1\\otimes x_2\\otimes\\ldots\\otimes x_n\\) , that's why a \\(n\\) -qubit state vector have \\(2^n\\) entries. The 2-qubit computational basis, will be, for example \\[\\begin{align*}\\vert00\\rangle &= \\left(\\begin{matrix}1\\cdot1\\\\1\\cdot0\\\\0\\cdot1\\\\0\\cdot0\\end{matrix}\\right)=\\left(\\begin{matrix}1\\\\0\\\\0\\\\0\\end{matrix}\\right)\\\\ \\vert01\\rangle &= \\left(\\begin{matrix}1\\cdot0\\\\1\\cdot1\\\\0\\cdot0\\\\0\\cdot1\\end{matrix}\\right)=\\left(\\begin{matrix}0\\\\1\\\\0\\\\0\\end{matrix}\\right)\\\\ \\vert10\\rangle &= \\left(\\begin{matrix}0\\cdot1\\\\0\\cdot0\\\\1\\cdot1\\\\1\\cdot0\\end{matrix}\\right)=\\left(\\begin{matrix}0\\\\0\\\\1\\\\0\\end{matrix}\\right)\\\\ \\vert11\\rangle &= \\left(\\begin{matrix}0\\cdot0\\\\0\\cdot1\\\\1\\cdot0\\\\1\\cdot1\\end{matrix}\\right)=\\left(\\begin{matrix}0\\\\0\\\\0\\\\1\\end{matrix}\\right)\\end{align*}\\] Notice the relation between binary form in the final vector, and that this basis is pairwise orthogonal. A general 2-qubit state can then be written in the computational basis as: \\[\\vert\\psi\\rangle = \\alpha_0\\vert00\\rangle+\\alpha_1\\vert01\\rangle+\\alpha_2\\vert10\\rangle+\\alpha_3\\vert11\\rangle\\] State \\(\\vert\\psi\\rangle\\) is said to be in superposition of the states \\(\\vert00\\rangle,\\vert01\\rangle,\\vert10\\rangle\\) and \\(\\vert11\\rangle\\) . Measurements and Born Rule Measuring a state in superposition is the way we can extract and read information about the quantum system. Quantum measurement collapses the state to one of the vectors of its orthogonal basis, with a given probability. From now on, consider \\(N=2^n\\) . We can do a projective measure of n-qubit state \\(\\displaystyle\\vert\\psi\\rangle=\\sum_{x=0}^{N-1}\\alpha_x\\vert x\\rangle\\) onto the orthogonal base \\(\\{\\vert 0\\rangle,\\vert 1\\rangle,\\ldots\\vert N-1\\rangle\\}\\) . Here, we are commiting an abuse of notation using \\(\\vert x\\rangle\\) (x in base 10) to represent the state \\(\\vert00\\ldots1\\ldots0\\rangle\\) , with the \\((x+1)^{th}\\) entriy being equal 1, and the rest zero. After this procedure, the state will colapse to either one of the \\(N\\) states from the basis, with probability of \\(|\\langle x\\vert\\psi\\rangle|^2\\) of collapsing to \\(x\\) . Thats's the so called Born Rule: \\[\\mathbb{P}(x)=|\\langle x\\vert\\psi\\rangle|^2\\] In the case of \\(\\vert\\psi\\rangle\\) written in computational basis, \\(\\mathbb{P}(x)=|\\alpha_x|^2\\) . Notice that, since \\(\\vert\\psi\\rangle\\) must be normalized, we'll have \\(\\displaystyle\\sum_{x=0}^{N-1}\\mathbb{P}(x) = \\sum_{x=0}^{N-1}|\\alpha_x|^2=1\\) , as expected. The Bloch Sphere We can write a single-qubit pure state as \\(\\vert\\psi\\rangle=\\cos\\frac \\theta 2\\vert0\\rangle+e^{\\varphi i}\\sin\\frac\\theta2\\vert1\\rangle\\) where \\(\\phi\\) is the relative phase of the state, and \\(\\theta\\) describes the probability of measuring basis states, such that \\(\\mathbb{P}(\\vert0\\rangle)=\\cos^2\\frac\\theta2\\) and \\(\\mathbb{P}(\\vert1\\rangle)=\\sin^2\\frac\\theta2\\) . All these states can be represented geometrically in the Bloch Sphere, an origin centered unitaty radius sphere, with maps the above state \\(\\vert\\psi\\rangle\\) to the 3D point: \\[\\vec r = \\left(\\begin{matrix}\\sin\\theta\\cos\\varphi\\\\\\sin\\theta\\sin\\varphi\\\\\\cos\\theta\\end{matrix}\\right)\\] The image below (ResearchGate) , shows the angle scheme and the axis poles states (read \\(v\\) as \\(\\vert\\psi\\rangle\\) ). We have saw before states \\(\\vert0\\rangle\\) and \\(\\vert1\\rangle\\) , but didn't mentioned \\(\\vert+\\rangle,\\vert-\\rangle\\) nor \\(\\vert+i\\rangle,\\vert-i\\rangle\\) . They are orthogonal pairs, with the formula shown in the image. Let's map these 6 states to its Blch Sphere point. On Z-axis: \\(\\vert0\\rangle\\) : \\(\\theta=0\\Rightarrow \\vec r = (\\begin{matrix}0 &0 &1\\end{matrix})^T\\) \\(\\vert1\\rangle\\) : \\(\\theta=\\pi\\Rightarrow \\vec r = (\\begin{matrix}0 &0 &-1\\end{matrix})^T\\) On X-axis: \\(\\vert+\\rangle\\) : \\(\\theta=\\pi/2,\\varphi=0\\Rightarrow \\vec r = \\left(\\begin{matrix}\\sin\\frac\\pi2 \\cos0\\\\\\sin\\frac\\pi2\\sin0 \\\\\\cos\\frac\\pi2\\end{matrix}\\right)=\\left(\\begin{matrix}1 \\\\0 \\\\0\\end{matrix}\\right)\\) \\(\\vert-\\rangle\\) : \\(\\theta=\\pi/2,\\varphi=\\pi\\Rightarrow \\vec r = \\left(\\begin{matrix}\\sin\\frac\\pi2 \\cos\\pi\\\\\\sin\\frac\\pi2\\sin\\pi \\\\\\cos\\frac\\pi2\\end{matrix}\\right)=\\left(\\begin{matrix}-1 \\\\0 \\\\0\\end{matrix}\\right)\\) And analogously (we won't explicit the calculations) on the Y-axis: \\(\\vert +i\\rangle\\Rightarrow \\vec r=\\left(\\begin{matrix}0 \\\\1 \\\\0\\end{matrix}\\right)\\) \\(\\vert -i\\rangle\\Rightarrow \\vec r =\\left(\\begin{matrix}0 \\\\-1 \\\\0\\end{matrix}\\right)\\) Such a geometric intuition will be important in Quantum Fourier Transform section, specially of the states zero, one, plus and minus. Quantum Circuits Quantum Circuit models are blocks that carry out elementary computational operations, the so called gates . In quantum theory, a gate is a unitary operator, i.e, a matrix \\(U\\) such that \\(U^\\dagger U = I\\) . See some examples of single-qubit gates: (Bit flip) \\(\\sigma_x=\\left(\\begin{matrix}0&1\\\\1&0\\end{matrix}\\right)\\) One can easyly show that \\(\\sigma_x\\vert0\\rangle = \\vert1\\rangle\\) and \\(\\sigma_x\\vert1\\rangle=\\vert0\\rangle\\) . In general, this gate performs a rotation around the x-axis by \\(pi\\) radians. (Phase flip) \\(\\sigma_z=\\left(\\begin{matrix}1&0\\\\ 0&-1\\end{matrix}\\right)\\) . It's easy to conclude that \\(\\sigma_z\\vert+\\rangle = \\vert-\\rangle\\) and \\(\\sigma_z\\vert-\\rangle = \\vert+\\rangle\\) . In general, this gate does a \\(pi\\) -radians rotation around the z-axis. (Hadamard gate) The most importante gate of this text: \\[H=\\dfrac{1}{\\sqrt2}\\left(\\begin{matrix}1&0\\\\0&-1\\end{matrix}\\right)\\] With a rapid calculation we get: \\[\\begin{align*}H\\vert0\\rangle&=\\vert+\\rangle=\\dfrac{1}{\\sqrt2}(\\vert0\\rangle+\\vert1\\rangle)\\\\ H\\vert1\\rangle&=\\vert-\\rangle=\\dfrac{1}{\\sqrt2}(\\vert0\\rangle-\\vert1\\rangle)\\end{align*}\\] Notice that this gate created a superposition of states zero and one, with probability 1/2 of measuring each one! That's what makes this gate so important, and we'll use-it a lot in the next sections. Qiskit Introduction Qiskit is a Python library that makes it esier to design and test quantum circuits and algorithms. You can follow the website instrutions to install it on your computer. We are going to create a basic circuit that applies Hadamard gate on \\(\\vert0\\rangle\\) , take the measurements and collapses to state zero or one. At first, let's import the required libraries: import warnings warnings.filterwarnings(\"ignore\",category=DeprecationWarning) from qiskit import QuantumCircuit, assemble, Aer from qiskit.visualization import plot_histogram Now lets build and display the circuit diagram: qc = QuantumCircuit(1) # Creates a single-qubit quantum circuit qc.initialize([1,0], 0) # Define initial_state as |0> qc.h(0) # Applid Hadamard Gate on 0th qubit (in this case, the only one) qc.measure_all() # Adds measurement to all qubits qc.draw() \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2510 q_0: \u2524 Initialize(1,0) \u251c\u2524 H \u251c\u2500\u2591\u2500\u2524M\u251c \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2565\u2518 meas: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 0 We're going to run this circuit in a quantum simulator, which does not require acess to an actual quantum device: sim = Aer.get_backend('qasm_simulator') # Defines the simulator qobj = assemble(qc,shots=1000) # Run 1000 shots of the circuit result = sim.run(qobj).result() #Collect results counts = result.get_counts() # Count results for plotting plot_histogram(counts) As expected, around half of the measurements collapses to \\(\\vert0\\rangle\\) and the other half to \\(\\vert1\\rangle\\) . The below table shows the library versions, if you want to reproduce the same environment used in this text. import qiskit.tools.jupyter %qiskit_version_table Version Information Qiskit Software Version qiskit-terra 0.18.3 qiskit-aer 0.6.1 qiskit-ignis 0.4.0 qiskit-ibmq-provider 0.8.0 qiskit-aqua 0.7.5 qiskit 0.32.0 System information Python 3.8.5 (default, Sep 3 2020, 21:29:08) [MSC v.1916 64 bit (AMD64)] OS Windows CPUs 2 Memory (Gb) 15.86971664428711 Wed Dec 01 21:24:13 2021 Hora oficial do Brasil","title":"3 - Quantum Computing Preliminaries"},{"location":"intro-quantum/#introduction-to-quantum-computing","text":"In classical computation, states (bits) are either 0 or 1, but quantum mechanics allows superposition of states, so a quantum state can be simultaneously 0 and 1. Such a superposition allows quantum computers to make calculations on more than one state at the same time. That's what makes possible the design of algorithms with exponentially speed-up such as Shor's Algorithm, which reduces to polynomial time, a task that runs in exponential time on classical computers. A quantum state in superposition can be measured, but once we do that, it collapses to one of its states with a given probability. That's what makes the design of quantum algorithms harder than classical ones because we have to draw a system that collapses to what we want with a high probability. This section seeks to introduce just the basic foundations of quantum computing as a background for the following sections. No prerequisite in quantum physics/mechanics is required. We'll present everything from the mathematical point of view, demanding just some prior knowledge in Linear Algebra and Complex Numbers.","title":"Introduction to Quantum Computing"},{"location":"intro-quantum/#quantum-states-and-dirac-notation","text":"We represent a \\(n\\) -qubit quantum state as a normalized vector in \\(\\mathbb{C}^{2^n}\\) (that's it!). Take for example, the single-qubit states \\(a,b\\in \\mathbb{C}^2\\) such that \\(a=\\left(\\begin{matrix}a_1\\\\ a_2\\end{matrix}\\right)\\) and \\(b=\\left(\\begin{matrix}b_1\\\\ b_2\\end{matrix}\\right)\\) with \\(a_1,a_2,b_1,b_2\\in\\mathbb{C}\\) . The so called Dirac notation is a shortcut for representing states and operations between them. ket: \\(\\vert a\\rangle = \\left(\\begin{matrix}a_1\\\\ a_2\\end{matrix}\\right)\\) The most used notation around this text, it's the way we represent a quantum state. bra: \\(\\langle b \\vert = \\vert b \\rangle^\\dagger=\\left(\\begin{matrix}b_1\\\\ b_2\\end{matrix}\\right)^\\dagger=\\left(\\begin{matrix}\\overline{b_1}& \\overline b_2\\end{matrix}\\right)\\) The bra is the conjugate transpose of a state (dagger notation \\(\\dagger\\) ). \\(\\overline b_1\\) means the complex conjugate of \\(b_1\\) . bra-ket: \\(\\langle b \\vert a\\rangle=a_1\\overline b_1+a_2\\overline b_2\\) A \"inner product\" between states. Observe that \\(\\langle b \\vert a\\rangle = \\overline {\\langle a\\vert b \\rangle}\\) . We say \\(a\\) and \\(b\\) are orthogonal states if \\(\\langle a\\vert b\\rangle = 0\\) . Not every complex vector can represent quantum states, because they need to be normalized, i.e, all states \\(\\vert\\psi\\rangle\\) must satisfy \\(\\langle\\psi\\vert\\psi\\rangle=1\\) . We define states \\(\\vert0\\rangle := \\left(\\begin{matrix}1\\\\0\\end{matrix}\\right)\\) and \\(\\vert1\\rangle:=\\left(\\begin{matrix}0\\\\1\\end{matrix}\\right)\\) . It's easy to see that \\(\\langle0\\vert1\\rangle=0\\) , so \\(\\vert0\\rangle\\) and \\(\\vert1\\rangle\\) are orthogonal. The general single-qubit state is then: \\[\\vert\\psi\\rangle = \\alpha_0\\vert0\\rangle+\\alpha_1\\vert1\\rangle,\\] with \\(\\alpha_0,\\alpha_1\\in\\mathbb{C}\\) and \\(|\\alpha_0|^2+|\\alpha_1|^2=1\\) We also define the tensor product of two states as: \\[\\vert a\\rangle\\otimes\\vert b\\rangle = \\left(\\begin{matrix}a_1b_1\\\\a_1b_2\\\\a_2b_1\\\\a_2b_2\\end{matrix}\\right)\\] This operation generalizes what we're doing in \\(\\mathbb{C}^2\\) to \\(\\mathbb{C}^{2^n}\\) . We defines the n-qubit computational basis as the set of all \\(2^n\\) possible tensor products of \\(\\vert0\\rangle\\) and \\(\\vert1\\rangle\\) . We can also represent tensor product with the notation \\(\\vert x_1x_2\\ldots x_n\\rangle:=x_1\\otimes x_2\\otimes\\ldots\\otimes x_n\\) , that's why a \\(n\\) -qubit state vector have \\(2^n\\) entries. The 2-qubit computational basis, will be, for example \\[\\begin{align*}\\vert00\\rangle &= \\left(\\begin{matrix}1\\cdot1\\\\1\\cdot0\\\\0\\cdot1\\\\0\\cdot0\\end{matrix}\\right)=\\left(\\begin{matrix}1\\\\0\\\\0\\\\0\\end{matrix}\\right)\\\\ \\vert01\\rangle &= \\left(\\begin{matrix}1\\cdot0\\\\1\\cdot1\\\\0\\cdot0\\\\0\\cdot1\\end{matrix}\\right)=\\left(\\begin{matrix}0\\\\1\\\\0\\\\0\\end{matrix}\\right)\\\\ \\vert10\\rangle &= \\left(\\begin{matrix}0\\cdot1\\\\0\\cdot0\\\\1\\cdot1\\\\1\\cdot0\\end{matrix}\\right)=\\left(\\begin{matrix}0\\\\0\\\\1\\\\0\\end{matrix}\\right)\\\\ \\vert11\\rangle &= \\left(\\begin{matrix}0\\cdot0\\\\0\\cdot1\\\\1\\cdot0\\\\1\\cdot1\\end{matrix}\\right)=\\left(\\begin{matrix}0\\\\0\\\\0\\\\1\\end{matrix}\\right)\\end{align*}\\] Notice the relation between binary form in the final vector, and that this basis is pairwise orthogonal. A general 2-qubit state can then be written in the computational basis as: \\[\\vert\\psi\\rangle = \\alpha_0\\vert00\\rangle+\\alpha_1\\vert01\\rangle+\\alpha_2\\vert10\\rangle+\\alpha_3\\vert11\\rangle\\] State \\(\\vert\\psi\\rangle\\) is said to be in superposition of the states \\(\\vert00\\rangle,\\vert01\\rangle,\\vert10\\rangle\\) and \\(\\vert11\\rangle\\) .","title":"Quantum States and Dirac Notation"},{"location":"intro-quantum/#measurements-and-born-rule","text":"Measuring a state in superposition is the way we can extract and read information about the quantum system. Quantum measurement collapses the state to one of the vectors of its orthogonal basis, with a given probability. From now on, consider \\(N=2^n\\) . We can do a projective measure of n-qubit state \\(\\displaystyle\\vert\\psi\\rangle=\\sum_{x=0}^{N-1}\\alpha_x\\vert x\\rangle\\) onto the orthogonal base \\(\\{\\vert 0\\rangle,\\vert 1\\rangle,\\ldots\\vert N-1\\rangle\\}\\) . Here, we are commiting an abuse of notation using \\(\\vert x\\rangle\\) (x in base 10) to represent the state \\(\\vert00\\ldots1\\ldots0\\rangle\\) , with the \\((x+1)^{th}\\) entriy being equal 1, and the rest zero. After this procedure, the state will colapse to either one of the \\(N\\) states from the basis, with probability of \\(|\\langle x\\vert\\psi\\rangle|^2\\) of collapsing to \\(x\\) . Thats's the so called Born Rule: \\[\\mathbb{P}(x)=|\\langle x\\vert\\psi\\rangle|^2\\] In the case of \\(\\vert\\psi\\rangle\\) written in computational basis, \\(\\mathbb{P}(x)=|\\alpha_x|^2\\) . Notice that, since \\(\\vert\\psi\\rangle\\) must be normalized, we'll have \\(\\displaystyle\\sum_{x=0}^{N-1}\\mathbb{P}(x) = \\sum_{x=0}^{N-1}|\\alpha_x|^2=1\\) , as expected.","title":"Measurements and Born Rule"},{"location":"intro-quantum/#the-bloch-sphere","text":"We can write a single-qubit pure state as \\(\\vert\\psi\\rangle=\\cos\\frac \\theta 2\\vert0\\rangle+e^{\\varphi i}\\sin\\frac\\theta2\\vert1\\rangle\\) where \\(\\phi\\) is the relative phase of the state, and \\(\\theta\\) describes the probability of measuring basis states, such that \\(\\mathbb{P}(\\vert0\\rangle)=\\cos^2\\frac\\theta2\\) and \\(\\mathbb{P}(\\vert1\\rangle)=\\sin^2\\frac\\theta2\\) . All these states can be represented geometrically in the Bloch Sphere, an origin centered unitaty radius sphere, with maps the above state \\(\\vert\\psi\\rangle\\) to the 3D point: \\[\\vec r = \\left(\\begin{matrix}\\sin\\theta\\cos\\varphi\\\\\\sin\\theta\\sin\\varphi\\\\\\cos\\theta\\end{matrix}\\right)\\] The image below (ResearchGate) , shows the angle scheme and the axis poles states (read \\(v\\) as \\(\\vert\\psi\\rangle\\) ). We have saw before states \\(\\vert0\\rangle\\) and \\(\\vert1\\rangle\\) , but didn't mentioned \\(\\vert+\\rangle,\\vert-\\rangle\\) nor \\(\\vert+i\\rangle,\\vert-i\\rangle\\) . They are orthogonal pairs, with the formula shown in the image. Let's map these 6 states to its Blch Sphere point. On Z-axis: \\(\\vert0\\rangle\\) : \\(\\theta=0\\Rightarrow \\vec r = (\\begin{matrix}0 &0 &1\\end{matrix})^T\\) \\(\\vert1\\rangle\\) : \\(\\theta=\\pi\\Rightarrow \\vec r = (\\begin{matrix}0 &0 &-1\\end{matrix})^T\\) On X-axis: \\(\\vert+\\rangle\\) : \\(\\theta=\\pi/2,\\varphi=0\\Rightarrow \\vec r = \\left(\\begin{matrix}\\sin\\frac\\pi2 \\cos0\\\\\\sin\\frac\\pi2\\sin0 \\\\\\cos\\frac\\pi2\\end{matrix}\\right)=\\left(\\begin{matrix}1 \\\\0 \\\\0\\end{matrix}\\right)\\) \\(\\vert-\\rangle\\) : \\(\\theta=\\pi/2,\\varphi=\\pi\\Rightarrow \\vec r = \\left(\\begin{matrix}\\sin\\frac\\pi2 \\cos\\pi\\\\\\sin\\frac\\pi2\\sin\\pi \\\\\\cos\\frac\\pi2\\end{matrix}\\right)=\\left(\\begin{matrix}-1 \\\\0 \\\\0\\end{matrix}\\right)\\) And analogously (we won't explicit the calculations) on the Y-axis: \\(\\vert +i\\rangle\\Rightarrow \\vec r=\\left(\\begin{matrix}0 \\\\1 \\\\0\\end{matrix}\\right)\\) \\(\\vert -i\\rangle\\Rightarrow \\vec r =\\left(\\begin{matrix}0 \\\\-1 \\\\0\\end{matrix}\\right)\\) Such a geometric intuition will be important in Quantum Fourier Transform section, specially of the states zero, one, plus and minus.","title":"The Bloch Sphere"},{"location":"intro-quantum/#quantum-circuits","text":"Quantum Circuit models are blocks that carry out elementary computational operations, the so called gates . In quantum theory, a gate is a unitary operator, i.e, a matrix \\(U\\) such that \\(U^\\dagger U = I\\) . See some examples of single-qubit gates: (Bit flip) \\(\\sigma_x=\\left(\\begin{matrix}0&1\\\\1&0\\end{matrix}\\right)\\) One can easyly show that \\(\\sigma_x\\vert0\\rangle = \\vert1\\rangle\\) and \\(\\sigma_x\\vert1\\rangle=\\vert0\\rangle\\) . In general, this gate performs a rotation around the x-axis by \\(pi\\) radians. (Phase flip) \\(\\sigma_z=\\left(\\begin{matrix}1&0\\\\ 0&-1\\end{matrix}\\right)\\) . It's easy to conclude that \\(\\sigma_z\\vert+\\rangle = \\vert-\\rangle\\) and \\(\\sigma_z\\vert-\\rangle = \\vert+\\rangle\\) . In general, this gate does a \\(pi\\) -radians rotation around the z-axis. (Hadamard gate) The most importante gate of this text: \\[H=\\dfrac{1}{\\sqrt2}\\left(\\begin{matrix}1&0\\\\0&-1\\end{matrix}\\right)\\] With a rapid calculation we get: \\[\\begin{align*}H\\vert0\\rangle&=\\vert+\\rangle=\\dfrac{1}{\\sqrt2}(\\vert0\\rangle+\\vert1\\rangle)\\\\ H\\vert1\\rangle&=\\vert-\\rangle=\\dfrac{1}{\\sqrt2}(\\vert0\\rangle-\\vert1\\rangle)\\end{align*}\\] Notice that this gate created a superposition of states zero and one, with probability 1/2 of measuring each one! That's what makes this gate so important, and we'll use-it a lot in the next sections.","title":"Quantum Circuits"},{"location":"intro-quantum/#qiskit-introduction","text":"Qiskit is a Python library that makes it esier to design and test quantum circuits and algorithms. You can follow the website instrutions to install it on your computer. We are going to create a basic circuit that applies Hadamard gate on \\(\\vert0\\rangle\\) , take the measurements and collapses to state zero or one. At first, let's import the required libraries: import warnings warnings.filterwarnings(\"ignore\",category=DeprecationWarning) from qiskit import QuantumCircuit, assemble, Aer from qiskit.visualization import plot_histogram Now lets build and display the circuit diagram: qc = QuantumCircuit(1) # Creates a single-qubit quantum circuit qc.initialize([1,0], 0) # Define initial_state as |0> qc.h(0) # Applid Hadamard Gate on 0th qubit (in this case, the only one) qc.measure_all() # Adds measurement to all qubits qc.draw() \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2510 q_0: \u2524 Initialize(1,0) \u251c\u2524 H \u251c\u2500\u2591\u2500\u2524M\u251c \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2565\u2518 meas: 1/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550 0 We're going to run this circuit in a quantum simulator, which does not require acess to an actual quantum device: sim = Aer.get_backend('qasm_simulator') # Defines the simulator qobj = assemble(qc,shots=1000) # Run 1000 shots of the circuit result = sim.run(qobj).result() #Collect results counts = result.get_counts() # Count results for plotting plot_histogram(counts) As expected, around half of the measurements collapses to \\(\\vert0\\rangle\\) and the other half to \\(\\vert1\\rangle\\) . The below table shows the library versions, if you want to reproduce the same environment used in this text. import qiskit.tools.jupyter %qiskit_version_table","title":"Qiskit Introduction"},{"location":"qft/","text":"Quantum Fourier Transform The Quantum Fourier Transform is just a change of basis, from the computational basis to Fourier one. It takes a quantum state \\(\\vert x \\rangle = \\vert x_1\\ldots x_n \\rangle\\) and maps it to: \\[\\underbrace{\\vert \\tilde x\\rangle}_{\\text{Fourier basis}}=QFT_N \\vert x \\rangle = \\dfrac{1}{\\sqrt{N}} \\sum_{y=0}^{N-1} e^{2 \\pi i xy / N} \\vert y \\rangle\\] Where \\(N=2^n\\) ( \\(n\\) = number of qubits) and \\(\\vert y\\rangle\\) represents its respective binary quantum state \\(\\vert y_1y_2\\ldots y_n\\rangle\\) , with \\(y_i\\in\\{0,1\\}\\) . (Actually, the sum \\(\\sum_{y=0}^{N-1}\\) is a shortcut notation for \\(\\displaystyle\\sum_{y_1=0}^1\\sum_{y_2=0}^{1}\\ldots\\sum_{y_n=0}^{1}\\) ) Examples Let's begin with the 1-qubit case, where \\(N=2^1\\) : \\[\\begin{align*} \\vert \\tilde 0 \\rangle&=\\dfrac{1}{\\sqrt2}\\displaystyle\\sum_{y=0}^{1}e^{2\\pi i (0)y/2}\\vert y\\rangle\\\\ &=\\dfrac{1}{\\sqrt2}\\displaystyle\\sum_{y=0}^{1}\\vert y\\rangle\\\\ &=\\dfrac{1}{\\sqrt2}(\\vert 0\\rangle + \\vert 1\\rangle)\\\\ &=\\vert + \\rangle \\end{align*}\\] \\[\\begin{align*} \\vert \\tilde 1 \\rangle&=\\dfrac{1}{\\sqrt2}\\displaystyle\\sum_{y=0}^{1}e^{2\\pi i (1)y/2}\\vert y\\rangle\\\\ &=\\dfrac{1}{\\sqrt2}\\left(e^{2\\pi i(0)/2}\\vert 0\\rangle+e^{2\\pi i(1)/2}\\vert 1\\rangle\\right)\\\\ &=\\dfrac{1}{\\sqrt2}(\\vert 0\\rangle + (-1)\\vert 1\\rangle)\\\\ &=\\dfrac{1}{\\sqrt2}(\\vert 0\\rangle -\\vert 1\\rangle\\\\ &=\\vert - \\rangle \\end{align*}\\] So states \\(\\vert0\\rangle\\) and \\(\\vert1\\rangle\\) are mapped to states \\(\\vert+\\rangle\\) and \\(\\vert-\\rangle\\) respectively. That's what Hadamard gate does! Geometrically, this transformation brings the z-axis poles states to the x-axis poles in the Bloch sphere. Qiskit Textbook have a nice animation which helps build intuition of what QFT does in the general case. A four-qubit state \\(\\vert x\\rangle = \\vert x_1x_2x_3x_4\\rangle\\) is stored using \\(\\vert0\\rangle\\) and \\(\\vert1\\rangle\\) in the computational basis. Observe that the leftmost qubit ( \\(x_4\\) ) flips with with every number increment, the next (qubit 1, \\(x_3\\) ) flips with 2 number increments, qubit 2 ( \\(x_2\\) ) flips after 4 turns, and so on. In the Fourier basis, all states are on the equatorial plane. The leftmost is rotated \\(2\\pi/16\\) radians by number increment, the next qubit ( \\(x_3\\) ) rotates \\(2\\pi/8\\) per time, \\(x_2\\) rotates \\(2\\pi/4\\) and \\(x_1\\) with an angle of \\(2\\pi/2=\\pi\\) radians. We are doubling the angle of rotation on each qubit. Quantum states math formulation The above animation of quantum states in the Fourier basis can be formalized with a bit of math manipulation on the QFT formula. As we briefly stated before, when we write \\(\\vert y\\rangle\\) we are representing the state \\(\\vert y_1y_2\\ldots y_n\\rangle\\) , so \\(y\\) in decimal base is \\(2^{n-1}y_1+2^{n-2}y_2+\\ldots +2^0y_n\\) . So replacing \\(\\vert y\\rangle\\) by its decimal representation, and the sum from \\(0\\) to \\(N-1\\) to the binary equivalent, we get: \\[\\begin{align*} QFT_N\\vert x\\rangle & = \\dfrac{1}{\\sqrt{N}} \\displaystyle\\sum_{y=0}^{N-1} e^{2 \\pi i xy / N} \\vert y \\rangle\\\\ &=\\displaystyle\\dfrac{1}{\\sqrt N}\\sum_{y_1=0}^1\\sum_{y_2=0}^{1}\\ldots\\sum_{y_n=0}^{1}\\exp\\left(\\frac{2\\pi ix}{N}\\sum_{k=1}^n2^{n-k}y_k\\right)\\vert y_1y_2\\ldots y_n\\rangle\\\\ &=\\dfrac{1}{\\sqrt N}\\sum_{y_1,y_2,\\ldots,y_n}\\prod_{k=1}^n\\exp\\left(\\frac{2\\pi ix}{N}y_k2^{n-k}\\right)\\vert y_1y_2\\ldots y_n\\rangle\\\\ &=\\dfrac{1}{\\sqrt N}\\sum_{y_1,y_2,\\ldots,y_n}\\prod_{k=1}^n\\exp\\left(2\\pi ixy_k2^{-k}\\right)\\vert y_1y_2\\ldots y_n\\rangle \\end{align*}\\] By swapping the order of the product and the sum, we got a tensor product: \\[\\begin{align*} &\\dfrac{1}{\\sqrt N}\\bigotimes_{k=1}^n\\left(e^{2\\pi ix(0)2^{-k}}\\vert 0\\rangle + e^{2\\pi ix (1)2^{-k}}\\vert1\\rangle\\right)\\\\ &=\\dfrac{1}{\\sqrt N}\\bigotimes_{k=1}^n\\left(\\vert 0\\rangle + e^{2\\pi ix 2^{-k}}\\vert1\\rangle\\right)\\\\ &=\\dfrac{1}{\\sqrt N}\\left(\\vert0\\rangle+e^{2\\pi ix/2}\\vert1\\rangle\\right)\\otimes\\left(\\vert0\\rangle+e^{2\\pi ix/4}\\vert1\\rangle\\right)\\otimes\\ldots\\otimes\\left(\\vert0\\rangle+e^{2\\pi i x/2^n}\\vert1\\rangle\\right) \\end{align*}\\] Notice we went from \\(\\vert x\\rangle = \\vert x_1\\rangle\\otimes\\vert x_2\\rangle\\otimes\\ldots\\otimes\\vert x_n\\rangle\\) to the state above, which tells us exatly what the the transform is doing to each entry of \\(x\\) . Regard constants, we have: \\[\\vert x_k\\rangle \\mapsto \\vert 0\\rangle + e^{2\\pi ix 2^{-k}}\\vert1\\rangle\\] Such an operation explains the above animation: the complex exponential term is responsible for the rotation seen. Moreover, this gives us hints for building a quantum circuit to implement QFT since we explicitly know what to do on each qubit. QFT Circuit We'll need two atomic elements for building a circuit that implements QFT: the already known Hadamard gate and the controlled rotation gate. We know that \\[H\\vert0\\rangle=\\frac{1}{\\sqrt2}(\\vert0\\rangle+\\vert1\\rangle)$$ and $$H\\vert1\\rangle=\\frac{1}{\\sqrt2}(\\vert0\\rangle-\\vert1\\rangle)\\] We can also write Hadamard operation acting on \\(x_k\\in\\{0,1\\}\\) as: \\[H\\vert x_k\\rangle\\dfrac{1}{\\sqrt2}\\left(\\vert0\\rangle+e^{2\\pi i x_k/2}\\vert1\\rangle\\right)\\] The other element, controlled rotation acts on two-qubit states \\(\\vert x_ix_j\\rangle\\) and is based on the following unitary operator: \\[UROT_k = \\left[\\begin{matrix} 1&0\\\\ 0&e^{2\\pi i/2^k}\\\\ \\end{matrix}\\right] \\] The, Controlled Rotation operator \\(CROT_k\\) will be the 4x4 matrix: \\[CROT_k = \\left[\\begin{matrix} I&0\\\\ 0&UROT_k\\\\ \\end{matrix}\\right]\\] Remember that \\(\\vert x_ix_j\\rangle=\\vert x_i\\rangle\\otimes\\vert x_j\\rangle\\) which is a columns vector with four entries, so the operation \\(CROT_k\\vert x_ix_j\\rangle\\) is dimentionally consistent. The first qubit \\(x_i\\) is the control qubit and tha second, \\(x_j\\) is the target one. So, as an example, se what happens when applying CROT to \\(\\vert0x_j\\rangle\\) and \\(\\vert1x_j\\rangle\\) : \\[\\begin{align*}CROT_k\\vert 0x_j\\rangle&=CROT_k\\vert 0\\rangle\\otimes\\vert x_j\\rangle=\\left[\\begin{matrix} I&0\\\\ 0&UROT_k\\\\ \\end{matrix}\\right]\\left(\\begin{matrix}x_{j1}\\\\x_{j2}\\\\0\\\\0\\end{matrix}\\right)\\\\ &=\\left(\\begin{matrix}x_{j1}\\\\x_{j2}\\\\0\\\\0\\end{matrix}\\right)\\\\&=\\vert0x_j\\rangle\\end{align*}\\] \\[\\begin{align*}CROT_k\\vert 1x_j\\rangle&=CROT_k\\vert 1\\rangle\\otimes\\vert x_j\\rangle=\\left[\\begin{matrix} I&0\\\\ 0&UROT_k\\\\ \\end{matrix}\\right]\\left(\\begin{matrix}0\\\\0\\\\x_{j1}\\\\x_{j2}\\end{matrix}\\right)\\\\&=\\left(\\begin{matrix}0\\\\0\\\\x_{j1}\\\\e^{2\\pi i/2^k}x_{j2}\\end{matrix}\\right)=\\vert1\\rangle\\otimes\\left(\\begin{matrix}e^{2\\pi i\\cdot0/2^k}x_{j1}\\\\e^{2\\pi i/2^k}x_{j2}\\end{matrix}\\right)\\\\&=e^{2\\pi x_j/2^k}\\vert1x_j\\rangle\\end{align*}\\] The QFT circuit is represented below: Let's see what's the state becomes on each checkpoited step: The input is the \\(n\\) -qubit state \\(\\vert x\\rangle=\\vert x_1x_2\\ldots x_n\\rangle\\) Step 1: Applys Hadamard gate on the first qubit. The state after that will be: \\[\\dfrac{1}{\\sqrt2}\\left[\\vert0\\rangle+e^{2\\pi i x_12^{-1}}\\vert1\\rangle\\right]\\otimes\\vert x_2x_3\\ldots x_n\\rangle\\] Step 2: Applys Unitary Rotarion \\(UROT_2\\) on the first qubit, controlled by the second. State after that: \\[\\dfrac{1}{\\sqrt2}\\left[\\vert0\\rangle+e^{2\\pi i x_22^{-2}}e^{2\\pi i x_12^{-1}}\\vert1\\rangle\\right]\\otimes\\vert x_2x_3\\ldots x_n\\rangle\\] Step 3: After applying \\(UROT_k\\) on qubit 1 controlled on qubit \\(k\\) with \\(k\\) from 2 to \\(n\\) , well get, following the above pattern: \\[\\dfrac{1}{\\sqrt2}\\left[\\vert0\\rangle+e^{2\\pi i x_n2^{-n}}e^{2\\pi i x_{n-1}2^{-(n-1)}}\\ldots e^{2\\pi i x_22^{-2}}e^{2\\pi i x_1 2^{-1}}\\vert1\\rangle\\right]\\otimes\\vert x_2x_3\\ldots x_n\\rangle\\] which is equal: \\[\\dfrac{1}{\\sqrt2}\\left[\\vert0\\rangle+\\exp{\\left(2\\pi i\\sum_{k=1}^nx_k2^{-k}\\right)}\\vert1\\rangle\\right]\\otimes\\vert x_2x_3\\ldots x_n\\rangle\\] But \\(x\\) in decimal base is \\(x=\\displaystyle\\sum_{k=1}^nx_k2^{n-k}\\) , so whats inside the above exponential is just \\(2\\pi i x/2^n\\) , we then simplyfies the output to: \\[\\dfrac{1}{\\sqrt2}\\left[\\vert0\\rangle+e^{2\\pi i x2^{-n}}\\vert1\\rangle\\right]\\otimes\\vert x_2x_3\\ldots x_n\\rangle\\] Step 4: We now apply the above block of steps to the remaining qubits, the process is very similar, and in the end the final state will be: \\[\\frac{1}{\\sqrt{2}} \\left[\\vert0\\rangle + e^{2\\pi i x2^{-n}} \\vert1\\rangle\\right] \\otimes \\frac{1}{\\sqrt{2}} \\left[\\vert0\\rangle + e^{2\\pi i x2^{-(n-1)}} \\vert1\\rangle\\right] \\otimes \\ldots \\otimes \\frac{1}{\\sqrt{2}} \\left[\\vert0\\rangle + e^{2\\pi i x2^{-2}} \\vert1\\rangle\\right] \\otimes \\frac{1}{\\sqrt{2}} \\left[\\vert0\\rangle + e^{2\\pi i x2^{-1}} \\vert1\\rangle\\right] \\] The constants multiplies to \\(\\frac{1}{\\sqrt N}\\) , so what we get as final state is just the formula derived previously, but in reversed order. Notice that the first transformed qubit is \\(\\vert0\\rangle + e^{2\\pi i x2^{-n}} \\vert1\\rangle\\) , where it was supposed to be \\(\\vert0\\rangle + e^{2\\pi i x2^{-1}} \\vert1\\rangle\\) in our desired QFT formula, but that's not a problem at all, we just reverse the order of qubits and done!","title":"4 - Quantum Fourier Transform"},{"location":"qft/#quantum-fourier-transform","text":"The Quantum Fourier Transform is just a change of basis, from the computational basis to Fourier one. It takes a quantum state \\(\\vert x \\rangle = \\vert x_1\\ldots x_n \\rangle\\) and maps it to: \\[\\underbrace{\\vert \\tilde x\\rangle}_{\\text{Fourier basis}}=QFT_N \\vert x \\rangle = \\dfrac{1}{\\sqrt{N}} \\sum_{y=0}^{N-1} e^{2 \\pi i xy / N} \\vert y \\rangle\\] Where \\(N=2^n\\) ( \\(n\\) = number of qubits) and \\(\\vert y\\rangle\\) represents its respective binary quantum state \\(\\vert y_1y_2\\ldots y_n\\rangle\\) , with \\(y_i\\in\\{0,1\\}\\) . (Actually, the sum \\(\\sum_{y=0}^{N-1}\\) is a shortcut notation for \\(\\displaystyle\\sum_{y_1=0}^1\\sum_{y_2=0}^{1}\\ldots\\sum_{y_n=0}^{1}\\) )","title":"Quantum Fourier Transform"},{"location":"qft/#examples","text":"Let's begin with the 1-qubit case, where \\(N=2^1\\) : \\[\\begin{align*} \\vert \\tilde 0 \\rangle&=\\dfrac{1}{\\sqrt2}\\displaystyle\\sum_{y=0}^{1}e^{2\\pi i (0)y/2}\\vert y\\rangle\\\\ &=\\dfrac{1}{\\sqrt2}\\displaystyle\\sum_{y=0}^{1}\\vert y\\rangle\\\\ &=\\dfrac{1}{\\sqrt2}(\\vert 0\\rangle + \\vert 1\\rangle)\\\\ &=\\vert + \\rangle \\end{align*}\\] \\[\\begin{align*} \\vert \\tilde 1 \\rangle&=\\dfrac{1}{\\sqrt2}\\displaystyle\\sum_{y=0}^{1}e^{2\\pi i (1)y/2}\\vert y\\rangle\\\\ &=\\dfrac{1}{\\sqrt2}\\left(e^{2\\pi i(0)/2}\\vert 0\\rangle+e^{2\\pi i(1)/2}\\vert 1\\rangle\\right)\\\\ &=\\dfrac{1}{\\sqrt2}(\\vert 0\\rangle + (-1)\\vert 1\\rangle)\\\\ &=\\dfrac{1}{\\sqrt2}(\\vert 0\\rangle -\\vert 1\\rangle\\\\ &=\\vert - \\rangle \\end{align*}\\] So states \\(\\vert0\\rangle\\) and \\(\\vert1\\rangle\\) are mapped to states \\(\\vert+\\rangle\\) and \\(\\vert-\\rangle\\) respectively. That's what Hadamard gate does! Geometrically, this transformation brings the z-axis poles states to the x-axis poles in the Bloch sphere. Qiskit Textbook have a nice animation which helps build intuition of what QFT does in the general case. A four-qubit state \\(\\vert x\\rangle = \\vert x_1x_2x_3x_4\\rangle\\) is stored using \\(\\vert0\\rangle\\) and \\(\\vert1\\rangle\\) in the computational basis. Observe that the leftmost qubit ( \\(x_4\\) ) flips with with every number increment, the next (qubit 1, \\(x_3\\) ) flips with 2 number increments, qubit 2 ( \\(x_2\\) ) flips after 4 turns, and so on. In the Fourier basis, all states are on the equatorial plane. The leftmost is rotated \\(2\\pi/16\\) radians by number increment, the next qubit ( \\(x_3\\) ) rotates \\(2\\pi/8\\) per time, \\(x_2\\) rotates \\(2\\pi/4\\) and \\(x_1\\) with an angle of \\(2\\pi/2=\\pi\\) radians. We are doubling the angle of rotation on each qubit.","title":"Examples"},{"location":"qft/#quantum-states-math-formulation","text":"The above animation of quantum states in the Fourier basis can be formalized with a bit of math manipulation on the QFT formula. As we briefly stated before, when we write \\(\\vert y\\rangle\\) we are representing the state \\(\\vert y_1y_2\\ldots y_n\\rangle\\) , so \\(y\\) in decimal base is \\(2^{n-1}y_1+2^{n-2}y_2+\\ldots +2^0y_n\\) . So replacing \\(\\vert y\\rangle\\) by its decimal representation, and the sum from \\(0\\) to \\(N-1\\) to the binary equivalent, we get: \\[\\begin{align*} QFT_N\\vert x\\rangle & = \\dfrac{1}{\\sqrt{N}} \\displaystyle\\sum_{y=0}^{N-1} e^{2 \\pi i xy / N} \\vert y \\rangle\\\\ &=\\displaystyle\\dfrac{1}{\\sqrt N}\\sum_{y_1=0}^1\\sum_{y_2=0}^{1}\\ldots\\sum_{y_n=0}^{1}\\exp\\left(\\frac{2\\pi ix}{N}\\sum_{k=1}^n2^{n-k}y_k\\right)\\vert y_1y_2\\ldots y_n\\rangle\\\\ &=\\dfrac{1}{\\sqrt N}\\sum_{y_1,y_2,\\ldots,y_n}\\prod_{k=1}^n\\exp\\left(\\frac{2\\pi ix}{N}y_k2^{n-k}\\right)\\vert y_1y_2\\ldots y_n\\rangle\\\\ &=\\dfrac{1}{\\sqrt N}\\sum_{y_1,y_2,\\ldots,y_n}\\prod_{k=1}^n\\exp\\left(2\\pi ixy_k2^{-k}\\right)\\vert y_1y_2\\ldots y_n\\rangle \\end{align*}\\] By swapping the order of the product and the sum, we got a tensor product: \\[\\begin{align*} &\\dfrac{1}{\\sqrt N}\\bigotimes_{k=1}^n\\left(e^{2\\pi ix(0)2^{-k}}\\vert 0\\rangle + e^{2\\pi ix (1)2^{-k}}\\vert1\\rangle\\right)\\\\ &=\\dfrac{1}{\\sqrt N}\\bigotimes_{k=1}^n\\left(\\vert 0\\rangle + e^{2\\pi ix 2^{-k}}\\vert1\\rangle\\right)\\\\ &=\\dfrac{1}{\\sqrt N}\\left(\\vert0\\rangle+e^{2\\pi ix/2}\\vert1\\rangle\\right)\\otimes\\left(\\vert0\\rangle+e^{2\\pi ix/4}\\vert1\\rangle\\right)\\otimes\\ldots\\otimes\\left(\\vert0\\rangle+e^{2\\pi i x/2^n}\\vert1\\rangle\\right) \\end{align*}\\] Notice we went from \\(\\vert x\\rangle = \\vert x_1\\rangle\\otimes\\vert x_2\\rangle\\otimes\\ldots\\otimes\\vert x_n\\rangle\\) to the state above, which tells us exatly what the the transform is doing to each entry of \\(x\\) . Regard constants, we have: \\[\\vert x_k\\rangle \\mapsto \\vert 0\\rangle + e^{2\\pi ix 2^{-k}}\\vert1\\rangle\\] Such an operation explains the above animation: the complex exponential term is responsible for the rotation seen. Moreover, this gives us hints for building a quantum circuit to implement QFT since we explicitly know what to do on each qubit.","title":"Quantum states math formulation"},{"location":"qft/#qft-circuit","text":"We'll need two atomic elements for building a circuit that implements QFT: the already known Hadamard gate and the controlled rotation gate. We know that \\[H\\vert0\\rangle=\\frac{1}{\\sqrt2}(\\vert0\\rangle+\\vert1\\rangle)$$ and $$H\\vert1\\rangle=\\frac{1}{\\sqrt2}(\\vert0\\rangle-\\vert1\\rangle)\\] We can also write Hadamard operation acting on \\(x_k\\in\\{0,1\\}\\) as: \\[H\\vert x_k\\rangle\\dfrac{1}{\\sqrt2}\\left(\\vert0\\rangle+e^{2\\pi i x_k/2}\\vert1\\rangle\\right)\\] The other element, controlled rotation acts on two-qubit states \\(\\vert x_ix_j\\rangle\\) and is based on the following unitary operator: \\[UROT_k = \\left[\\begin{matrix} 1&0\\\\ 0&e^{2\\pi i/2^k}\\\\ \\end{matrix}\\right] \\] The, Controlled Rotation operator \\(CROT_k\\) will be the 4x4 matrix: \\[CROT_k = \\left[\\begin{matrix} I&0\\\\ 0&UROT_k\\\\ \\end{matrix}\\right]\\] Remember that \\(\\vert x_ix_j\\rangle=\\vert x_i\\rangle\\otimes\\vert x_j\\rangle\\) which is a columns vector with four entries, so the operation \\(CROT_k\\vert x_ix_j\\rangle\\) is dimentionally consistent. The first qubit \\(x_i\\) is the control qubit and tha second, \\(x_j\\) is the target one. So, as an example, se what happens when applying CROT to \\(\\vert0x_j\\rangle\\) and \\(\\vert1x_j\\rangle\\) : \\[\\begin{align*}CROT_k\\vert 0x_j\\rangle&=CROT_k\\vert 0\\rangle\\otimes\\vert x_j\\rangle=\\left[\\begin{matrix} I&0\\\\ 0&UROT_k\\\\ \\end{matrix}\\right]\\left(\\begin{matrix}x_{j1}\\\\x_{j2}\\\\0\\\\0\\end{matrix}\\right)\\\\ &=\\left(\\begin{matrix}x_{j1}\\\\x_{j2}\\\\0\\\\0\\end{matrix}\\right)\\\\&=\\vert0x_j\\rangle\\end{align*}\\] \\[\\begin{align*}CROT_k\\vert 1x_j\\rangle&=CROT_k\\vert 1\\rangle\\otimes\\vert x_j\\rangle=\\left[\\begin{matrix} I&0\\\\ 0&UROT_k\\\\ \\end{matrix}\\right]\\left(\\begin{matrix}0\\\\0\\\\x_{j1}\\\\x_{j2}\\end{matrix}\\right)\\\\&=\\left(\\begin{matrix}0\\\\0\\\\x_{j1}\\\\e^{2\\pi i/2^k}x_{j2}\\end{matrix}\\right)=\\vert1\\rangle\\otimes\\left(\\begin{matrix}e^{2\\pi i\\cdot0/2^k}x_{j1}\\\\e^{2\\pi i/2^k}x_{j2}\\end{matrix}\\right)\\\\&=e^{2\\pi x_j/2^k}\\vert1x_j\\rangle\\end{align*}\\] The QFT circuit is represented below: Let's see what's the state becomes on each checkpoited step: The input is the \\(n\\) -qubit state \\(\\vert x\\rangle=\\vert x_1x_2\\ldots x_n\\rangle\\) Step 1: Applys Hadamard gate on the first qubit. The state after that will be: \\[\\dfrac{1}{\\sqrt2}\\left[\\vert0\\rangle+e^{2\\pi i x_12^{-1}}\\vert1\\rangle\\right]\\otimes\\vert x_2x_3\\ldots x_n\\rangle\\] Step 2: Applys Unitary Rotarion \\(UROT_2\\) on the first qubit, controlled by the second. State after that: \\[\\dfrac{1}{\\sqrt2}\\left[\\vert0\\rangle+e^{2\\pi i x_22^{-2}}e^{2\\pi i x_12^{-1}}\\vert1\\rangle\\right]\\otimes\\vert x_2x_3\\ldots x_n\\rangle\\] Step 3: After applying \\(UROT_k\\) on qubit 1 controlled on qubit \\(k\\) with \\(k\\) from 2 to \\(n\\) , well get, following the above pattern: \\[\\dfrac{1}{\\sqrt2}\\left[\\vert0\\rangle+e^{2\\pi i x_n2^{-n}}e^{2\\pi i x_{n-1}2^{-(n-1)}}\\ldots e^{2\\pi i x_22^{-2}}e^{2\\pi i x_1 2^{-1}}\\vert1\\rangle\\right]\\otimes\\vert x_2x_3\\ldots x_n\\rangle\\] which is equal: \\[\\dfrac{1}{\\sqrt2}\\left[\\vert0\\rangle+\\exp{\\left(2\\pi i\\sum_{k=1}^nx_k2^{-k}\\right)}\\vert1\\rangle\\right]\\otimes\\vert x_2x_3\\ldots x_n\\rangle\\] But \\(x\\) in decimal base is \\(x=\\displaystyle\\sum_{k=1}^nx_k2^{n-k}\\) , so whats inside the above exponential is just \\(2\\pi i x/2^n\\) , we then simplyfies the output to: \\[\\dfrac{1}{\\sqrt2}\\left[\\vert0\\rangle+e^{2\\pi i x2^{-n}}\\vert1\\rangle\\right]\\otimes\\vert x_2x_3\\ldots x_n\\rangle\\] Step 4: We now apply the above block of steps to the remaining qubits, the process is very similar, and in the end the final state will be: \\[\\frac{1}{\\sqrt{2}} \\left[\\vert0\\rangle + e^{2\\pi i x2^{-n}} \\vert1\\rangle\\right] \\otimes \\frac{1}{\\sqrt{2}} \\left[\\vert0\\rangle + e^{2\\pi i x2^{-(n-1)}} \\vert1\\rangle\\right] \\otimes \\ldots \\otimes \\frac{1}{\\sqrt{2}} \\left[\\vert0\\rangle + e^{2\\pi i x2^{-2}} \\vert1\\rangle\\right] \\otimes \\frac{1}{\\sqrt{2}} \\left[\\vert0\\rangle + e^{2\\pi i x2^{-1}} \\vert1\\rangle\\right] \\] The constants multiplies to \\(\\frac{1}{\\sqrt N}\\) , so what we get as final state is just the formula derived previously, but in reversed order. Notice that the first transformed qubit is \\(\\vert0\\rangle + e^{2\\pi i x2^{-n}} \\vert1\\rangle\\) , where it was supposed to be \\(\\vert0\\rangle + e^{2\\pi i x2^{-1}} \\vert1\\rangle\\) in our desired QFT formula, but that's not a problem at all, we just reverse the order of qubits and done!","title":"QFT Circuit"},{"location":"quantum-shors/","text":"Shor's Algorithm - Implementation In this section we'll design the algorithm described in Section 2 , putting together the classical part, and all quantum ingredients we saw in previous sections. In order to design a quantum circuit to return the period \\(r\\) of \\(f(x)=a^x~(mod~ 15)\\) , we'll need a Quantum Phase Estimation Circuit . Although we didn't covered its details here, we're going to explain what it does and you can see the details in the link provided. What Quantum Phase Estimation (QPE) does is: Given a Unitary operator \\(U\\) and its eigenstate \\(\\psi\\) (an eigenstate is such that \\(U\\vert\\psi\\rangle=e^{i\\theta_\\psi}\\vert\\psi\\rangle\\) ) returns its phase \\(\\theta_\\psi\\) . Actually, what it really does, is collapsing to \\(2^n\\theta\\) , considering \\(U\\vert\\psi\\rangle=e^{2\\pi i\\theta}\\vert\\psi\\rangle\\) . In the case of factoring, the Unitary operator will be: \\[U|y\\rangle \\equiv |ay \\bmod N \\rangle\\] with the eigenstates \\(u_s\\) having the phase \\(2\\pi s/r\\) : \\[\\begin{aligned} |u_s\\rangle &= \\tfrac{1}{\\sqrt{r}}\\sum_{k=0}^{r-1}{e^{-\\tfrac{2\\pi i s k}{r}}|a^k \\bmod N\\rangle}\\\\ U|u_s\\rangle &= e^{\\tfrac{2\\pi i s}{r}}|u_s\\rangle \\end{aligned} \\] In the below circuit, we'll then measure \\(2^ns/r\\) , but the only thing that matters is that \\(r\\) is in the denominator, and we can use continued fraction algorithm to extract it. Python have a built-in library for dealing with fractions, and we'll use it, also as a black box, further details of such algorithm can be found in (Nielsen & Chuang, 2011) . The circuit is implemented below, we used the modular exponentiation implementation from Qiskit Textbook, and will treat as a black box, since we don't want to enter in quantum efficiency discussion of this process. # Imports import warnings warnings.filterwarnings(\"ignore\",category=DeprecationWarning) from qiskit import QuantumCircuit, Aer from qiskit.circuit.library import QFT def a_x_mod15(a, x): if a not in [2,7,8,11,13]: raise ValueError(\"'a' must be 2,7,8,11 or 13\") U = QuantumCircuit(4) for iteration in range(x): if a in [2,13]: U.swap(0,1) U.swap(1,2) U.swap(2,3) if a in [7,8]: U.swap(2,3) U.swap(1,2) U.swap(0,1) if a == 11: U.swap(1,3) U.swap(0,2) if a in [7,11,13]: for q in range(4): U.x(q) U = U.to_gate() U.name = \"%i^%i mod 15\" % (a, x) c_U = U.control() return c_U def modular_exponentiation(given_circuit, n, m, a): for x in range(n): exponent = 2**x given_circuit.append(a_x_mod15(a, exponent), [x] + list(range(n, n+m))) def shor_circuit(a,n,m): # Input : a - guess for factor of 15 # n - number of measurements # m - number of target qubits # Setting up circuit shor = QuantumCircuit(n+m, n) # Initializing firsts n qubits with Hadamard shor.h(range(n)) # Applying sigma_x gate to last qubit shor.x(n+m-1) #Apply modular exponentiation gates modular_exponentiation(shor, n, m, a) shor.barrier() #Apply inverse QFT shor.append(QFT(n, do_swaps=False).inverse(), range(n)) # measure the first n qubits shor.measure(range(n), range(n)) return shor See the illustration of the circuit with \\(a=2\\) n = 4; m = 4; a = 2 shor_example = shor_circuit(a,n,m) shor_example.draw() \u250c\u2500\u2500\u2500\u2510 \u2591 \u00bb q_0: \u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u00bb \u251c\u2500\u2500\u2500\u2524 \u2502 \u2591 \u00bb q_1: \u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u00bb \u251c\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2591 \u00bb q_2: \u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u00bb \u251c\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2502 \u2591 \u00bb q_3: \u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u00bb \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u00bb q_4: \u2500\u2500\u2500\u2500\u2500\u25240 \u251c\u25240 \u251c\u25240 \u251c\u25240 \u251c\u2500\u2591\u2500\u00bb \u2502 \u2502\u2502 \u2502\u2502 \u2502\u2502 \u2502 \u2591 \u00bb q_5: \u2500\u2500\u2500\u2500\u2500\u25241 \u251c\u25241 \u251c\u25241 \u251c\u25241 \u251c\u2500\u2591\u2500\u00bb \u2502 2^1 mod 15 \u2502\u2502 2^2 mod 15 \u2502\u2502 2^4 mod 15 \u2502\u2502 2^8 mod 15 \u2502 \u2591 \u00bb q_6: \u2500\u2500\u2500\u2500\u2500\u25242 \u251c\u25242 \u251c\u25242 \u251c\u25242 \u251c\u2500\u2591\u2500\u00bb \u250c\u2500\u2500\u2500\u2510\u2502 \u2502\u2502 \u2502\u2502 \u2502\u2502 \u2502 \u2591 \u00bb q_7: \u2524 X \u251c\u25243 \u251c\u25243 \u251c\u25243 \u251c\u25243 \u251c\u2500\u2591\u2500\u00bb \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591 \u00bb c: 4/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u00bb \u00bb \u00ab \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2510 \u00abq_0: \u25240 \u251c\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u00ab \u2502 \u2502\u2514\u2565\u2518\u250c\u2500\u2510 \u00abq_1: \u25241 \u251c\u2500\u256b\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500 \u00ab \u2502 IQFT \u2502 \u2551 \u2514\u2565\u2518\u250c\u2500\u2510 \u00abq_2: \u25242 \u251c\u2500\u256b\u2500\u2500\u256b\u2500\u2524M\u251c\u2500\u2500\u2500 \u00ab \u2502 \u2502 \u2551 \u2551 \u2514\u2565\u2518\u250c\u2500\u2510 \u00abq_3: \u25243 \u251c\u2500\u256b\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2524M\u251c \u00ab \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551 \u2551 \u2551 \u2514\u2565\u2518 \u00abq_4: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2500\u256b\u2500 \u00ab \u2551 \u2551 \u2551 \u2551 \u00abq_5: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2500\u256b\u2500 \u00ab \u2551 \u2551 \u2551 \u2551 \u00abq_6: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2500\u256b\u2500 \u00ab \u2551 \u2551 \u2551 \u2551 \u00abq_7: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2500\u256b\u2500 \u00ab \u2551 \u2551 \u2551 \u2551 \u00abc: 4/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550 \u00ab 0 1 2 3 With the circuit implemented, we can follow with further pre-processing and post-processing of Shor's Algorithm","title":"5 - Shor's Algorithm - Implementation"},{"location":"quantum-shors/#shors-algorithm-implementation","text":"In this section we'll design the algorithm described in Section 2 , putting together the classical part, and all quantum ingredients we saw in previous sections. In order to design a quantum circuit to return the period \\(r\\) of \\(f(x)=a^x~(mod~ 15)\\) , we'll need a Quantum Phase Estimation Circuit . Although we didn't covered its details here, we're going to explain what it does and you can see the details in the link provided. What Quantum Phase Estimation (QPE) does is: Given a Unitary operator \\(U\\) and its eigenstate \\(\\psi\\) (an eigenstate is such that \\(U\\vert\\psi\\rangle=e^{i\\theta_\\psi}\\vert\\psi\\rangle\\) ) returns its phase \\(\\theta_\\psi\\) . Actually, what it really does, is collapsing to \\(2^n\\theta\\) , considering \\(U\\vert\\psi\\rangle=e^{2\\pi i\\theta}\\vert\\psi\\rangle\\) . In the case of factoring, the Unitary operator will be: \\[U|y\\rangle \\equiv |ay \\bmod N \\rangle\\] with the eigenstates \\(u_s\\) having the phase \\(2\\pi s/r\\) : \\[\\begin{aligned} |u_s\\rangle &= \\tfrac{1}{\\sqrt{r}}\\sum_{k=0}^{r-1}{e^{-\\tfrac{2\\pi i s k}{r}}|a^k \\bmod N\\rangle}\\\\ U|u_s\\rangle &= e^{\\tfrac{2\\pi i s}{r}}|u_s\\rangle \\end{aligned} \\] In the below circuit, we'll then measure \\(2^ns/r\\) , but the only thing that matters is that \\(r\\) is in the denominator, and we can use continued fraction algorithm to extract it. Python have a built-in library for dealing with fractions, and we'll use it, also as a black box, further details of such algorithm can be found in (Nielsen & Chuang, 2011) . The circuit is implemented below, we used the modular exponentiation implementation from Qiskit Textbook, and will treat as a black box, since we don't want to enter in quantum efficiency discussion of this process. # Imports import warnings warnings.filterwarnings(\"ignore\",category=DeprecationWarning) from qiskit import QuantumCircuit, Aer from qiskit.circuit.library import QFT def a_x_mod15(a, x): if a not in [2,7,8,11,13]: raise ValueError(\"'a' must be 2,7,8,11 or 13\") U = QuantumCircuit(4) for iteration in range(x): if a in [2,13]: U.swap(0,1) U.swap(1,2) U.swap(2,3) if a in [7,8]: U.swap(2,3) U.swap(1,2) U.swap(0,1) if a == 11: U.swap(1,3) U.swap(0,2) if a in [7,11,13]: for q in range(4): U.x(q) U = U.to_gate() U.name = \"%i^%i mod 15\" % (a, x) c_U = U.control() return c_U def modular_exponentiation(given_circuit, n, m, a): for x in range(n): exponent = 2**x given_circuit.append(a_x_mod15(a, exponent), [x] + list(range(n, n+m))) def shor_circuit(a,n,m): # Input : a - guess for factor of 15 # n - number of measurements # m - number of target qubits # Setting up circuit shor = QuantumCircuit(n+m, n) # Initializing firsts n qubits with Hadamard shor.h(range(n)) # Applying sigma_x gate to last qubit shor.x(n+m-1) #Apply modular exponentiation gates modular_exponentiation(shor, n, m, a) shor.barrier() #Apply inverse QFT shor.append(QFT(n, do_swaps=False).inverse(), range(n)) # measure the first n qubits shor.measure(range(n), range(n)) return shor See the illustration of the circuit with \\(a=2\\) n = 4; m = 4; a = 2 shor_example = shor_circuit(a,n,m) shor_example.draw() \u250c\u2500\u2500\u2500\u2510 \u2591 \u00bb q_0: \u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u00bb \u251c\u2500\u2500\u2500\u2524 \u2502 \u2591 \u00bb q_1: \u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u00bb \u251c\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2591 \u00bb q_2: \u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u00bb \u251c\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2502 \u2591 \u00bb q_3: \u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2591\u2500\u00bb \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u00bb q_4: \u2500\u2500\u2500\u2500\u2500\u25240 \u251c\u25240 \u251c\u25240 \u251c\u25240 \u251c\u2500\u2591\u2500\u00bb \u2502 \u2502\u2502 \u2502\u2502 \u2502\u2502 \u2502 \u2591 \u00bb q_5: \u2500\u2500\u2500\u2500\u2500\u25241 \u251c\u25241 \u251c\u25241 \u251c\u25241 \u251c\u2500\u2591\u2500\u00bb \u2502 2^1 mod 15 \u2502\u2502 2^2 mod 15 \u2502\u2502 2^4 mod 15 \u2502\u2502 2^8 mod 15 \u2502 \u2591 \u00bb q_6: \u2500\u2500\u2500\u2500\u2500\u25242 \u251c\u25242 \u251c\u25242 \u251c\u25242 \u251c\u2500\u2591\u2500\u00bb \u250c\u2500\u2500\u2500\u2510\u2502 \u2502\u2502 \u2502\u2502 \u2502\u2502 \u2502 \u2591 \u00bb q_7: \u2524 X \u251c\u25243 \u251c\u25243 \u251c\u25243 \u251c\u25243 \u251c\u2500\u2591\u2500\u00bb \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591 \u00bb c: 4/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u00bb \u00bb \u00ab \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2510 \u00abq_0: \u25240 \u251c\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u00ab \u2502 \u2502\u2514\u2565\u2518\u250c\u2500\u2510 \u00abq_1: \u25241 \u251c\u2500\u256b\u2500\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500 \u00ab \u2502 IQFT \u2502 \u2551 \u2514\u2565\u2518\u250c\u2500\u2510 \u00abq_2: \u25242 \u251c\u2500\u256b\u2500\u2500\u256b\u2500\u2524M\u251c\u2500\u2500\u2500 \u00ab \u2502 \u2502 \u2551 \u2551 \u2514\u2565\u2518\u250c\u2500\u2510 \u00abq_3: \u25243 \u251c\u2500\u256b\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2524M\u251c \u00ab \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551 \u2551 \u2551 \u2514\u2565\u2518 \u00abq_4: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2500\u256b\u2500 \u00ab \u2551 \u2551 \u2551 \u2551 \u00abq_5: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2500\u256b\u2500 \u00ab \u2551 \u2551 \u2551 \u2551 \u00abq_6: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2500\u256b\u2500 \u00ab \u2551 \u2551 \u2551 \u2551 \u00abq_7: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2500\u256b\u2500\u2500\u256b\u2500 \u00ab \u2551 \u2551 \u2551 \u2551 \u00abc: 4/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550 \u00ab 0 1 2 3 With the circuit implemented, we can follow with further pre-processing and post-processing of Shor's Algorithm","title":"Shor's Algorithm  - Implementation"},{"location":"shors-algorithm/","text":"Shor's Algorithm import markdown md = markdown.Markdown(extensions=['pymdownx.arithmatex']) Pseudocode Getting straight to the point, here's how Shor's algorithm works to factor a prime product \\(N=pq\\) : Pick a random integer \\(a\\) between \\(0\\) and \\(N-1\\) ; Find the smallest \\(r\\) such that \\(a^r\\equiv 1 ~(mod ~N)\\) , i.e the period of the function \\(f(x)=a^x~(mod~N)\\) ; If r is odd, get back to step 1 If \\(a^{r/2}+1\\equiv 0~(mod~N)\\) , get back to step 1. Then \\(\\{p,q\\}=\\{\\gcd(a^{r/2}-1,N),\\gcd(a^{r/2}+1,N)\\}\\) . Why does it works? Let \\(G_N\\) be the set of all positive integers less than N, that are coprimes with N. One can show that this is a group under modulo- \\(N\\) multiplication. Step 1 chooses a random \\(a\\in \\mathbb{Z}_N\\) , if we are lucky to choose an \\(a\\) which share factors with \\(N\\) , we just use Euclidean Algorithm for \\(\\gcd(N,a)\\) and finish the factoring process. But in most cases we'll choose a number in \\(G_N\\) . Step 2 finds the order \\(r\\) of \\(a\\) in \\(G_N\\) . Then, we calculate \\(x=a^{r/2}~(mod~N)\\) (step 3 garantees \\(r\\) is even), and open up the expression: \\[\\begin{align*} (x-1)(x+1)&\\equiv x^2-1~(mod ~N)\\\\ &\\equiv a^r-1~(mod ~N)\\\\ &\\equiv 0 ~(mod ~N),\\\\ \\end{align*}\\] since \\(a^r\\equiv1~(mod~N)\\) Note that \\(x-1\\not\\equiv 0 ~(mod ~N)\\) , because \\(r\\) is the smallest number s.t. \\(a^r-1\\equiv0~(mod~N)\\) , so \\(a^{r/2}-1\\) does not satisfy the equivalence. Step 4, also garantees \\(x+1\\not\\equiv0~(mod~N)\\) . So, we have that neither \\(x-1\\) nor \\(x+1\\) is divisible by \\(N=pq\\) , but their product \\((x-1)(x+1)\\) is. Since \\(N\\) has just two prime factors, \\(p\\) must divide \\(x-1\\) or \\(x+1\\) and \\(q\\) the other term. Probability of Success Shor's Algorithm counts on the luck of finding an \\(a\\) which goes through steps 3 and 4 without restarting the process. But we don't need to try it out many times because the probability of a random number \\(a\\in G_N\\) have order \\(r\\) which is even and satisfy \\(a^{r/2}+1\\not\\equiv0~(mod~N)\\) , is at least \\(50\\%\\) ! We'll prove a more general theorem: Theorem 1: Let \\(N=p_1^{\\alpha_1}p_2^{\\alpha_2}\\ldots p_m^{\\alpha_m}\\) the prime factorization of a positive composite number \\(N\\) . If \\(a\\) is an uniformly random number choosen from \\(G_N\\) , and \\(r\\) its order modulo \\(N\\) , then: \\[\\mathbb{P}\\left(\\text{r is even and }a^{r/2}+1\\not\\equiv0~(mod~N)\\right )\\geq1-\\dfrac{1}{2^{m-1}}\\] Then, in the case where \\(N=pq\\) ( \\(m=2\\) ), the probability of success is greater or equal \\(1/2\\) . At first, consider \\(N\\) being an odd prime number (because even primes won't appear in encryption applications). We'll have \\(|G_N|=\\varphi(N)=N-1\\) , an even number, so consider \\(2^d\\) the large power of 2 diving \\(N-1\\) . As said before, it can be show that \\(G_N\\) is a cyclic group under modulo \\(N\\) multiplication. So there is a generator \\(g\\) such that any element from \\(G_N\\) can be written as \\(g^t~(mod~N)\\) . If \\(r\\) is the order of \\(g^t\\) , then \\(g^{tr}\\equiv1~(mod~N)\\) . By Lagrange's Theorem , \\(tr|N-1\\) . If \\(t\\) is odd, then \\(2^d\\) must divide \\(r\\) , so \\(r\\) is even. If \\(t\\) happens to be even, we'll have: \\[g^{(N-1)t/2}\\equiv(g^{(N-1)})^{t/2}\\equiv1~(mod~N),\\] so \\(r|(N-1)/2\\) since \\(r\\) is the order of \\(g^t\\) and \\((g^t)^{(N-1)/2}\\equiv1~(mod~N)\\) . This implies that \\(2^d\\) does not divide \\(r\\) , because if that was the case, we would have \\(2^{d+1}|N-1\\) , absurd by the definition of \\(2^d\\) as largest power of two dividing \\(N-1\\) . So, the probability of a random number in \\(G_N\\) have an order divisible by \\(2^d\\) is 1/2 (because \\(t\\) is equaly likely to be odd or even). Now, consider \\(N\\) being power of an odd prime \\(N=p^{\\alpha}\\) . The same argument still holds replacing \\(N-1\\) by \\(|G_N| = \\varphi(N)=p^{\\alpha-1}(p-1)\\) . So, if \\(2^d\\) is the largest power of two dividing \\(\\varphi(N)\\) , then a randomly choosen \\(a\\in G_N\\) have its order \\(r\\) divisible by \\(2^d\\) with probability \\(1/2\\) . We're gonnna prove the general case where \\(N=p_1^{\\alpha_1}p_2^{\\alpha_2}\\ldots p_m^{\\alpha_m}\\) , as a consequence of the following theorem: Theorem 2 (Chinese Remainder Theorem): Suppose \\(n_1,n_2,\\ldots,n_k\\) are positive integers pairwise coprimes. Then the system of equations: \\[\\begin{align*} x &\\equiv a_1~(mod~n_1)\\\\ x &\\equiv a_2~(mod~n_2)\\\\ \\vdots&~~~~~\\vdots~~~~~~~~~\\vdots\\\\ x &\\equiv a_k~(mod~n_k) \\end{align*}\\] has a solution. Moreover, if \\(x_1\\) and \\(x_2\\) are solutions, \\(x_1\\equiv x_2~(mod~N)\\) , where \\(N=n_1n_2\\ldots n_k\\) . By the above theorem, choosing \\(a\\in G_N\\) randomly, is equivalent to choose for each \\(i=1,\\ldots,m\\) , a random \\(a_i\\in G_{p_i^{\\alpha_i}}\\) , and requiring \\(a\\equiv a_i~(mod~p_i^{\\alpha_i})\\) for all \\(i\\) . Let \\(r_i\\) be the order of \\(a_i~(mod~p_i^{\\alpha_i})\\) , and \\(2^{d_i}\\) the largest power of two dividing \\(r_i\\) . The order \\(r\\) of \\(a\\) will be the lowest commom divisor of \\(r_1,\\ldots,r_m\\) . Shor's algorithm only fails if all powers \\(2^{d_i}\\) agree. If \\(d_i=0~\\forall~i=1,\\ldots,m\\) , then \\(r\\) will be odd. For each \\(i\\) , the probability of \\(r_i\\) beaing odd is \\(1/2\\) , since we are in the case of power of a prime \\(p_i^{\\alpha_i}\\) . Then of \\(r_i\\) 's will be odd, with probability \\(1/2^{m}\\) . The other case of failure is when \\(r\\) is even and \\(a^{r/2}\\equiv-1~(mod~N)\\) . If this happens, then for all \\(i\\) , \\(a^{r/2}\\equiv-1~(mod~p_i^{\\alpha_i})\\) . So \\(r_i\\) does not divides \\(r/2\\) , because if that was the case \\(a^{r/2}\\) would be \\(1\\) modulo \\(p_i^{\\alpha_i}\\) . Since \\(r_i|r\\) , all of \\(d_i\\) 's must agree. As seen before, \\(r_1\\) will be divisible by a power of \\(2\\) (the largest dividing \\(\\varphi(p_1^{\\alpha_2}\\) ) with probability \\(1/2\\) . Then the probability of each other \\(r_i\\) 's have it's \\(d_i\\) agreeing with \\(d_1\\) will be at most \\(1/2\\) (considering the worst case scenario). Then \\(\\mathbb{P}(r\\text{ even and }a^{r/2}\\equiv-1~(mod~N))\\leq\\dfrac1{2^m}\\) . And since \\(\\mathbb{P}(r \\text{ odd})=\\dfrac1{2^m}\\) , then probability of failure is: \\[\\mathbb{P}(r\\text{ odd or }a^{r/2}\\equiv-1~(mod~N))\\leq\\dfrac1{2^m}+\\dfrac{1}{2^m}=\\dfrac{1}{2^{m-1}}\\] Finally, the probability of sucess is \\[\\mathbb{P}(r\\text{ even and }a^{r/2}\\not\\equiv-1~(mod~N))\\geq1-\\dfrac{1}{2^{m-1}} ~~\\blacksquare\\]","title":"2 - Shor's Algorithm - Theory"},{"location":"shors-algorithm/#shors-algorithm","text":"import markdown md = markdown.Markdown(extensions=['pymdownx.arithmatex'])","title":"Shor's Algorithm"},{"location":"shors-algorithm/#pseudocode","text":"Getting straight to the point, here's how Shor's algorithm works to factor a prime product \\(N=pq\\) : Pick a random integer \\(a\\) between \\(0\\) and \\(N-1\\) ; Find the smallest \\(r\\) such that \\(a^r\\equiv 1 ~(mod ~N)\\) , i.e the period of the function \\(f(x)=a^x~(mod~N)\\) ; If r is odd, get back to step 1 If \\(a^{r/2}+1\\equiv 0~(mod~N)\\) , get back to step 1. Then \\(\\{p,q\\}=\\{\\gcd(a^{r/2}-1,N),\\gcd(a^{r/2}+1,N)\\}\\) .","title":"Pseudocode"},{"location":"shors-algorithm/#why-does-it-works","text":"Let \\(G_N\\) be the set of all positive integers less than N, that are coprimes with N. One can show that this is a group under modulo- \\(N\\) multiplication. Step 1 chooses a random \\(a\\in \\mathbb{Z}_N\\) , if we are lucky to choose an \\(a\\) which share factors with \\(N\\) , we just use Euclidean Algorithm for \\(\\gcd(N,a)\\) and finish the factoring process. But in most cases we'll choose a number in \\(G_N\\) . Step 2 finds the order \\(r\\) of \\(a\\) in \\(G_N\\) . Then, we calculate \\(x=a^{r/2}~(mod~N)\\) (step 3 garantees \\(r\\) is even), and open up the expression: \\[\\begin{align*} (x-1)(x+1)&\\equiv x^2-1~(mod ~N)\\\\ &\\equiv a^r-1~(mod ~N)\\\\ &\\equiv 0 ~(mod ~N),\\\\ \\end{align*}\\] since \\(a^r\\equiv1~(mod~N)\\) Note that \\(x-1\\not\\equiv 0 ~(mod ~N)\\) , because \\(r\\) is the smallest number s.t. \\(a^r-1\\equiv0~(mod~N)\\) , so \\(a^{r/2}-1\\) does not satisfy the equivalence. Step 4, also garantees \\(x+1\\not\\equiv0~(mod~N)\\) . So, we have that neither \\(x-1\\) nor \\(x+1\\) is divisible by \\(N=pq\\) , but their product \\((x-1)(x+1)\\) is. Since \\(N\\) has just two prime factors, \\(p\\) must divide \\(x-1\\) or \\(x+1\\) and \\(q\\) the other term.","title":"Why does it works?"},{"location":"shors-algorithm/#probability-of-success","text":"Shor's Algorithm counts on the luck of finding an \\(a\\) which goes through steps 3 and 4 without restarting the process. But we don't need to try it out many times because the probability of a random number \\(a\\in G_N\\) have order \\(r\\) which is even and satisfy \\(a^{r/2}+1\\not\\equiv0~(mod~N)\\) , is at least \\(50\\%\\) ! We'll prove a more general theorem: Theorem 1: Let \\(N=p_1^{\\alpha_1}p_2^{\\alpha_2}\\ldots p_m^{\\alpha_m}\\) the prime factorization of a positive composite number \\(N\\) . If \\(a\\) is an uniformly random number choosen from \\(G_N\\) , and \\(r\\) its order modulo \\(N\\) , then: \\[\\mathbb{P}\\left(\\text{r is even and }a^{r/2}+1\\not\\equiv0~(mod~N)\\right )\\geq1-\\dfrac{1}{2^{m-1}}\\] Then, in the case where \\(N=pq\\) ( \\(m=2\\) ), the probability of success is greater or equal \\(1/2\\) . At first, consider \\(N\\) being an odd prime number (because even primes won't appear in encryption applications). We'll have \\(|G_N|=\\varphi(N)=N-1\\) , an even number, so consider \\(2^d\\) the large power of 2 diving \\(N-1\\) . As said before, it can be show that \\(G_N\\) is a cyclic group under modulo \\(N\\) multiplication. So there is a generator \\(g\\) such that any element from \\(G_N\\) can be written as \\(g^t~(mod~N)\\) . If \\(r\\) is the order of \\(g^t\\) , then \\(g^{tr}\\equiv1~(mod~N)\\) . By Lagrange's Theorem , \\(tr|N-1\\) . If \\(t\\) is odd, then \\(2^d\\) must divide \\(r\\) , so \\(r\\) is even. If \\(t\\) happens to be even, we'll have: \\[g^{(N-1)t/2}\\equiv(g^{(N-1)})^{t/2}\\equiv1~(mod~N),\\] so \\(r|(N-1)/2\\) since \\(r\\) is the order of \\(g^t\\) and \\((g^t)^{(N-1)/2}\\equiv1~(mod~N)\\) . This implies that \\(2^d\\) does not divide \\(r\\) , because if that was the case, we would have \\(2^{d+1}|N-1\\) , absurd by the definition of \\(2^d\\) as largest power of two dividing \\(N-1\\) . So, the probability of a random number in \\(G_N\\) have an order divisible by \\(2^d\\) is 1/2 (because \\(t\\) is equaly likely to be odd or even). Now, consider \\(N\\) being power of an odd prime \\(N=p^{\\alpha}\\) . The same argument still holds replacing \\(N-1\\) by \\(|G_N| = \\varphi(N)=p^{\\alpha-1}(p-1)\\) . So, if \\(2^d\\) is the largest power of two dividing \\(\\varphi(N)\\) , then a randomly choosen \\(a\\in G_N\\) have its order \\(r\\) divisible by \\(2^d\\) with probability \\(1/2\\) . We're gonnna prove the general case where \\(N=p_1^{\\alpha_1}p_2^{\\alpha_2}\\ldots p_m^{\\alpha_m}\\) , as a consequence of the following theorem: Theorem 2 (Chinese Remainder Theorem): Suppose \\(n_1,n_2,\\ldots,n_k\\) are positive integers pairwise coprimes. Then the system of equations: \\[\\begin{align*} x &\\equiv a_1~(mod~n_1)\\\\ x &\\equiv a_2~(mod~n_2)\\\\ \\vdots&~~~~~\\vdots~~~~~~~~~\\vdots\\\\ x &\\equiv a_k~(mod~n_k) \\end{align*}\\] has a solution. Moreover, if \\(x_1\\) and \\(x_2\\) are solutions, \\(x_1\\equiv x_2~(mod~N)\\) , where \\(N=n_1n_2\\ldots n_k\\) . By the above theorem, choosing \\(a\\in G_N\\) randomly, is equivalent to choose for each \\(i=1,\\ldots,m\\) , a random \\(a_i\\in G_{p_i^{\\alpha_i}}\\) , and requiring \\(a\\equiv a_i~(mod~p_i^{\\alpha_i})\\) for all \\(i\\) . Let \\(r_i\\) be the order of \\(a_i~(mod~p_i^{\\alpha_i})\\) , and \\(2^{d_i}\\) the largest power of two dividing \\(r_i\\) . The order \\(r\\) of \\(a\\) will be the lowest commom divisor of \\(r_1,\\ldots,r_m\\) . Shor's algorithm only fails if all powers \\(2^{d_i}\\) agree. If \\(d_i=0~\\forall~i=1,\\ldots,m\\) , then \\(r\\) will be odd. For each \\(i\\) , the probability of \\(r_i\\) beaing odd is \\(1/2\\) , since we are in the case of power of a prime \\(p_i^{\\alpha_i}\\) . Then of \\(r_i\\) 's will be odd, with probability \\(1/2^{m}\\) . The other case of failure is when \\(r\\) is even and \\(a^{r/2}\\equiv-1~(mod~N)\\) . If this happens, then for all \\(i\\) , \\(a^{r/2}\\equiv-1~(mod~p_i^{\\alpha_i})\\) . So \\(r_i\\) does not divides \\(r/2\\) , because if that was the case \\(a^{r/2}\\) would be \\(1\\) modulo \\(p_i^{\\alpha_i}\\) . Since \\(r_i|r\\) , all of \\(d_i\\) 's must agree. As seen before, \\(r_1\\) will be divisible by a power of \\(2\\) (the largest dividing \\(\\varphi(p_1^{\\alpha_2}\\) ) with probability \\(1/2\\) . Then the probability of each other \\(r_i\\) 's have it's \\(d_i\\) agreeing with \\(d_1\\) will be at most \\(1/2\\) (considering the worst case scenario). Then \\(\\mathbb{P}(r\\text{ even and }a^{r/2}\\equiv-1~(mod~N))\\leq\\dfrac1{2^m}\\) . And since \\(\\mathbb{P}(r \\text{ odd})=\\dfrac1{2^m}\\) , then probability of failure is: \\[\\mathbb{P}(r\\text{ odd or }a^{r/2}\\equiv-1~(mod~N))\\leq\\dfrac1{2^m}+\\dfrac{1}{2^m}=\\dfrac{1}{2^{m-1}}\\] Finally, the probability of sucess is \\[\\mathbb{P}(r\\text{ even and }a^{r/2}\\not\\equiv-1~(mod~N))\\geq1-\\dfrac{1}{2^{m-1}} ~~\\blacksquare\\]","title":"Probability of Success"}]}