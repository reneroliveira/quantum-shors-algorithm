{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Breaking RSA Encryption The security of RSA encryption, as briefly described below, is based on the computational difficulty of factoring large numbers. The best-known algorithm, General Number Field Sieve by (Lenstra et al., 1990a) performs this task in sub-exponential time \\(O\\left(e^{1.9(\\log N)^{1/3}(\\log\\log N)^{2/3}}\\right)\\) , where \\(N\\) is the number being factored (then \\(\\log N\\) would be the order of the number of input bits) In 1994, Peter Shor came up with a Las Vegas algorithm for prime factorization and discrete logarithms that take advantage of quantum computation to achieve a polynomial complexity in the number of bits, which is \\(O\\left((\\log N)^2(\\log\\log N)(\\log \\log\\log N)\\right)\\) . RSA Preliminaries Suppose Alice wants to send a message \\(a\\) to Bob (as an ASCII integer). Bob picks two prime numbers (preferably large) \\(p\\) and \\(q\\) and multiplies them to get \\(N=pq\\) . Also, he chooses a large number \\(c\\) , coprime with \\((p-1)(q-1)\\) . After that, he shares with Alice the public keys \\((N,c)\\) . Alice uses the keys received from Bob to encrypt the message, calculating \\(b\\equiv a^c~(mod ~N)\\) , and sends it to Bob. Since he knows \\(p\\) and \\(q\\) , she can compute \\(d\\) (private key) such that \\(cd\\equiv1 ~(mod~ (p-1)(q-1))\\) thought B\u00e9zout coefficients of Extended Euclidean algorithm , then he can decrypt the message \\(b\\) , through \\(b^d~(mod~N)\\) . This works because \\(a^{(p-1)(q-1)}\\equiv 1 ~(mod~N)\\) , and since \\(cd\\) can be written as \\(1+k(p-1)(q-1)\\) for some \\(k\\in\\mathbb{Z}\\) , we get: \\[\\begin{align*} &b^d~(mod~N)\\\\ \\equiv&~a^{cd}~(mod~N)\\\\ \\equiv&~a^{1+k(p-1)(q-1)}~(mod~N)\\\\ \\equiv&~a~(mod~N) \\end{align*}\\] This is just a summary, for a deeper explanation of the group theory involved in this encryption, you can check sections 3.2 and 3.3 of (Mermin, 2007) . But now, we understand the \"vulnerability\" of RSA. If a hacker gets \\(p\\) and \\(q\\) just knowing its product \\(N\\) , he could effortlessly generate the private key \\(d\\) and decrypt the message. That's why in practical applications, \\(p\\) and \\(q\\) are huge numbers with hundreds of digits of length. Project Structure Section 2 describes Shor's Algorithm and the number theory behind it. It relies on finding the period \\(r\\) of a discrete periodic function, in that case \\(f(x)=a^x~(mod~N)\\) . That's the key part of the algorithm which can be done efficiently on a quantum computer, using the Quantum Fourier Transform (QFT), presented in Section 4 . Section 3 gives a basic background in quantum computing concepts, and how to implement quantum circuits using Qiskit library , for then you jump into the QFT section. Finally, Section 5 shows a practical example of factoring using a quantum computer. We use \\(15\\) for the experiment and explain the caveats for factoring higher order numbers. Section 6 is a selection of excellent materials available on the internet regarding quantum computing and cryptography. And Section 7 contains the bibliographical references.","title":"1 - Introduction"},{"location":"#breaking-rsa-encryption","text":"The security of RSA encryption, as briefly described below, is based on the computational difficulty of factoring large numbers. The best-known algorithm, General Number Field Sieve by (Lenstra et al., 1990a) performs this task in sub-exponential time \\(O\\left(e^{1.9(\\log N)^{1/3}(\\log\\log N)^{2/3}}\\right)\\) , where \\(N\\) is the number being factored (then \\(\\log N\\) would be the order of the number of input bits) In 1994, Peter Shor came up with a Las Vegas algorithm for prime factorization and discrete logarithms that take advantage of quantum computation to achieve a polynomial complexity in the number of bits, which is \\(O\\left((\\log N)^2(\\log\\log N)(\\log \\log\\log N)\\right)\\) .","title":"Breaking RSA Encryption"},{"location":"#rsa-preliminaries","text":"Suppose Alice wants to send a message \\(a\\) to Bob (as an ASCII integer). Bob picks two prime numbers (preferably large) \\(p\\) and \\(q\\) and multiplies them to get \\(N=pq\\) . Also, he chooses a large number \\(c\\) , coprime with \\((p-1)(q-1)\\) . After that, he shares with Alice the public keys \\((N,c)\\) . Alice uses the keys received from Bob to encrypt the message, calculating \\(b\\equiv a^c~(mod ~N)\\) , and sends it to Bob. Since he knows \\(p\\) and \\(q\\) , she can compute \\(d\\) (private key) such that \\(cd\\equiv1 ~(mod~ (p-1)(q-1))\\) thought B\u00e9zout coefficients of Extended Euclidean algorithm , then he can decrypt the message \\(b\\) , through \\(b^d~(mod~N)\\) . This works because \\(a^{(p-1)(q-1)}\\equiv 1 ~(mod~N)\\) , and since \\(cd\\) can be written as \\(1+k(p-1)(q-1)\\) for some \\(k\\in\\mathbb{Z}\\) , we get: \\[\\begin{align*} &b^d~(mod~N)\\\\ \\equiv&~a^{cd}~(mod~N)\\\\ \\equiv&~a^{1+k(p-1)(q-1)}~(mod~N)\\\\ \\equiv&~a~(mod~N) \\end{align*}\\] This is just a summary, for a deeper explanation of the group theory involved in this encryption, you can check sections 3.2 and 3.3 of (Mermin, 2007) . But now, we understand the \"vulnerability\" of RSA. If a hacker gets \\(p\\) and \\(q\\) just knowing its product \\(N\\) , he could effortlessly generate the private key \\(d\\) and decrypt the message. That's why in practical applications, \\(p\\) and \\(q\\) are huge numbers with hundreds of digits of length.","title":"RSA Preliminaries"},{"location":"#project-structure","text":"Section 2 describes Shor's Algorithm and the number theory behind it. It relies on finding the period \\(r\\) of a discrete periodic function, in that case \\(f(x)=a^x~(mod~N)\\) . That's the key part of the algorithm which can be done efficiently on a quantum computer, using the Quantum Fourier Transform (QFT), presented in Section 4 . Section 3 gives a basic background in quantum computing concepts, and how to implement quantum circuits using Qiskit library , for then you jump into the QFT section. Finally, Section 5 shows a practical example of factoring using a quantum computer. We use \\(15\\) for the experiment and explain the caveats for factoring higher order numbers. Section 6 is a selection of excellent materials available on the internet regarding quantum computing and cryptography. And Section 7 contains the bibliographical references.","title":"Project Structure"},{"location":"bib/","text":"References A. K. Lenstra, H. W. Lenstra, M. S. Manasse, and J. M. Pollard. 1990. The number field sieve. In Proceedings of the twenty-second annual ACM symposium on Theory of Computing (STOC '90). Association for Computing Machinery, New York, NY, USA, 564\u2013572. DOI:https://doi.org/10.1145/100216.100295 Mermin, N. D. (2007). Quantum Computer Science. Cambridge University Press.","title":"7 - References"},{"location":"bib/#references","text":"A. K. Lenstra, H. W. Lenstra, M. S. Manasse, and J. M. Pollard. 1990. The number field sieve. In Proceedings of the twenty-second annual ACM symposium on Theory of Computing (STOC '90). Association for Computing Machinery, New York, NY, USA, 564\u2013572. DOI:https://doi.org/10.1145/100216.100295 Mermin, N. D. (2007). Quantum Computer Science. Cambridge University Press.","title":"References"},{"location":"further/","text":"Further Reading Recommended materials Original Shor's paper Mermins book Qiskkit textbook qiskit summer course shor's interview breaking eliptical curve","title":"6 - Further reading"},{"location":"further/#further-reading","text":"Recommended materials Original Shor's paper Mermins book Qiskkit textbook qiskit summer course shor's interview breaking eliptical curve","title":"Further Reading"},{"location":"intro-quantum/","text":"Introduction to Quantum Computing Qubits, dirac notation, measurements, bloch sphere, quantum circuits, q-sphere","title":"3 - Quantum Computing Preliminaries"},{"location":"intro-quantum/#introduction-to-quantum-computing","text":"Qubits, dirac notation, measurements, bloch sphere, quantum circuits, q-sphere","title":"Introduction to Quantum Computing"},{"location":"qft/","text":"Quantum Fourier Transform import numpy as np from numpy import pi # importing Qiskit from qiskit import QuantumCircuit, transpile, assemble, Aer, IBMQ from qiskit.providers.ibmq import least_busy from qiskit.tools.monitor import job_monitor from qiskit.visualization import plot_histogram, plot_bloch_multivector import warnings warnings.filterwarnings(\"ignore\") qc = QuantumCircuit(3) qc.h(2) qc.draw() q_0: \u2500\u2500\u2500\u2500\u2500 q_1: \u2500\u2500\u2500\u2500\u2500 \u250c\u2500\u2500\u2500\u2510 q_2: \u2524 H \u251c \u2514\u2500\u2500\u2500\u2518 qc.cp(pi/2, 1, 2) # CROT from qubit 1 to qubit 2 qc.draw() q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u250c\u2500\u2500\u2500\u2510 \u2502P(\u03c0/2) q_2: \u2524 H \u251c\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2514\u2500\u2500\u2500\u2518","title":"4 - Quantum Fourier Transform"},{"location":"qft/#quantum-fourier-transform","text":"import numpy as np from numpy import pi # importing Qiskit from qiskit import QuantumCircuit, transpile, assemble, Aer, IBMQ from qiskit.providers.ibmq import least_busy from qiskit.tools.monitor import job_monitor from qiskit.visualization import plot_histogram, plot_bloch_multivector import warnings warnings.filterwarnings(\"ignore\") qc = QuantumCircuit(3) qc.h(2) qc.draw() q_0: \u2500\u2500\u2500\u2500\u2500 q_1: \u2500\u2500\u2500\u2500\u2500 \u250c\u2500\u2500\u2500\u2510 q_2: \u2524 H \u251c \u2514\u2500\u2500\u2500\u2518 qc.cp(pi/2, 1, 2) # CROT from qubit 1 to qubit 2 qc.draw() q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 q_1: \u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u250c\u2500\u2500\u2500\u2510 \u2502P(\u03c0/2) q_2: \u2524 H \u251c\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2514\u2500\u2500\u2500\u2518","title":"Quantum Fourier Transform"},{"location":"quantum-shors/","text":"Quantum Shor's Algorithm","title":"5 - Quantum Shor's Algorithm"},{"location":"quantum-shors/#quantum-shors-algorithm","text":"","title":"Quantum Shor's Algorithm"},{"location":"shors-algorithm/","text":"Shor's Algorithm import markdown md = markdown.Markdown(extensions=['pymdownx.arithmatex']) Pseudocode Getting straigth to the point, here's how Shor's algorithm works to factor a prime product \\(N=pq\\) : Pick a random integer \\(a\\) between \\(0\\) and \\(N-1\\) ; Find the smallest \\(r\\) such that \\(a^r\\equiv 1 ~(mod ~N)\\) , i.e the period of the function \\(f(x)=a^x~(mod~N)\\) ; If r is odd, get back to step 1 If \\(a^{r/2}+1\\equiv 0~(mod~N)\\) , get back to step 1. Then \\(\\{p,q\\}=\\{\\gcd(a^{r/2}-1,N),\\gcd(a^{r/2}+1,N)\\}\\) .","title":"2 - Shor's Algorithm"},{"location":"shors-algorithm/#shors-algorithm","text":"import markdown md = markdown.Markdown(extensions=['pymdownx.arithmatex'])","title":"Shor's Algorithm"},{"location":"shors-algorithm/#pseudocode","text":"Getting straigth to the point, here's how Shor's algorithm works to factor a prime product \\(N=pq\\) : Pick a random integer \\(a\\) between \\(0\\) and \\(N-1\\) ; Find the smallest \\(r\\) such that \\(a^r\\equiv 1 ~(mod ~N)\\) , i.e the period of the function \\(f(x)=a^x~(mod~N)\\) ; If r is odd, get back to step 1 If \\(a^{r/2}+1\\equiv 0~(mod~N)\\) , get back to step 1. Then \\(\\{p,q\\}=\\{\\gcd(a^{r/2}-1,N),\\gcd(a^{r/2}+1,N)\\}\\) .","title":"Pseudocode"}]}